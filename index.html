<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Notflix Portal">
    <title>Plex Request Portal</title>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js';
        import { getAuth, signInWithCredential, GoogleAuthProvider } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js';

        // API client for backend communication
        class ApiClient {
            constructor() {
                this.baseUrl = window.location.origin;
                this.currentUser = null;
                this.idToken = null;
            }

            async getConfig() {
                try {
                    const response = await fetch(`${this.baseUrl}/api/config`);
                    return await response.json();
                } catch (error) {
                    console.error('Failed to get config:', error);
                    throw error;
                }
            }

            async verifyAuth(idToken) {
                try {
                    const response = await fetch(`${this.baseUrl}/api/auth/verify`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ idToken })
                    });
                    
                    if (!response.ok) throw new Error('Auth verification failed');
                    return await response.json();
                } catch (error) {
                    console.error('Auth verification error:', error);
                    throw error;
                }
            }

            async getUserRequests(userId) {
                try {
                    const response = await fetch(`${this.baseUrl}/api/requests/${userId}`);
                    if (!response.ok) throw new Error('Failed to fetch requests');
                    return await response.json();
                } catch (error) {
                    console.error('Get requests error:', error);
                    throw error;
                }
            }

            async getGlobalAvailability(tmdbId, type) {
                try {
                    const response = await fetch(`${this.baseUrl}/api/availability/${tmdbId}?type=${type}`);
                    if (!response.ok) throw new Error('Failed to fetch global availability');
                    return await response.json();
                } catch (error) {
                    console.error('Global availability error:', error);
                    throw error;
                }
            }

            async createRequest(requestData) {
                try {
                    const response = await fetch(`${this.baseUrl}/api/requests`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestData)
                    });
                    
                    if (!response.ok) throw new Error('Failed to create request');
                    return await response.json();
                } catch (error) {
                    console.error('Create request error:', error);
                    throw error;
                }
            }

            async getUserData(userId) {
                try {
                    const response = await fetch(`${this.baseUrl}/api/user/${userId}`);
                    if (!response.ok) throw new Error('Failed to fetch user data');
                    return await response.json();
                } catch (error) {
                    console.error('Get user data error:', error);
                    throw error;
                }
            }

            // Server-Sent Events for real-time updates
            listenForUpdates(userId, callback) {
                const eventSource = new EventSource(`${this.baseUrl}/api/requests/${userId}/listen`);
                
                eventSource.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        callback(data);
                    } catch (error) {
                        console.error('SSE parse error:', error);
                    }
                };

                eventSource.onerror = function(error) {
                    console.error('SSE connection error:', error);
                };

                return eventSource;
            }
        }

        // Initialize API client
        window.apiClient = new ApiClient();

        // Initialize Firebase with config from backend
        let firebaseApp, auth;
        
        window.apiClient.getConfig().then(config => {
            firebaseApp = initializeApp(config.firebase);
            auth = getAuth(firebaseApp);
            window.firebaseApp = firebaseApp;
            window.auth = auth;
            window.tmdbApiKey = config.tmdbApiKey;
            console.log('üî• Firebase initialized securely via backend');
            console.log('üé¨ TMDB API key loaded:', config.tmdbApiKey ? 'YES' : 'NO');
            
            // Load popular content AFTER config is loaded
            loadPopularContent();
        }).catch(error => {
            console.error('Failed to initialize Firebase:', error);
        });

        // Expose necessary Firebase functions
        window.GoogleAuthProvider = GoogleAuthProvider;
        window.signInWithCredential = signInWithCredential;
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        input, textarea, button {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3a 50%, #2d1b4e 100%);
            color: #ffffff;
            min-height: 100vh;
            transition: all 0.3s ease;
            -webkit-overflow-scrolling: touch;
            position: relative;
            padding-bottom: env(safe-area-inset-bottom);
        }

        body.light-mode {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 50%, #dee2e6 100%);
            color: #212529;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            padding-top: max(20px, env(safe-area-inset-top));
            padding-bottom: max(20px, env(safe-area-inset-bottom));
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px 0;
            position: relative;
            padding-top: max(50px, env(safe-area-inset-top) + 30px);
        }

        .theme-toggle {
            position: absolute;
            top: max(10px, env(safe-area-inset-top) + 10px);
            right: 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 6px 12px;
            color: #ffffff;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            z-index: 100;
            min-width: 100px;
            justify-content: center;
        }

        .theme-toggle:hover, .theme-toggle:active {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(0.98);
        }

        .light-mode .theme-toggle {
            background: rgba(0, 0, 0, 0.1);
            border-color: rgba(0, 0, 0, 0.2);
            color: #212529;
        }

        .light-mode .theme-toggle:hover, .light-mode .theme-toggle:active {
            background: rgba(0, 0, 0, 0.2);
        }

        .beta-badge {
            position: absolute;
            top: max(10px, env(safe-area-inset-top) + 10px);
            left: 15px;
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
            color: white;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 2px 10px rgba(255, 107, 107, 0.3);
            animation: pulseGlow 2s infinite alternate;
            z-index: 100;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .light-mode .beta-badge {
            border-color: rgba(0, 0, 0, 0.1);
        }

        @keyframes pulseGlow {
            0% {
                box-shadow: 0 2px 10px rgba(255, 107, 107, 0.3);
                transform: scale(1);
            }
            100% {
                box-shadow: 0 4px 20px rgba(255, 107, 107, 0.6);
                transform: scale(1.02);
            }
        }

        .header h1 {
            font-size: clamp(1.6rem, 4.5vw, 2.5rem);
            font-weight: 700;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            padding: 0 130px;
        }

        .header-subtitle {
            font-size: clamp(0.85rem, 2.8vw, 1.1rem);
            color: #a0a0a0;
            font-weight: 300;
            padding: 0 20px;
            line-height: 1.4;
        }

        .light-mode .header-subtitle {
            color: #6c757d;
        }

        .search-section {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .light-mode .search-section {
            background: rgba(255, 255, 255, 0.7);
            border-color: rgba(0, 0, 0, 0.1);
        }

        .search-container {
            position: relative;
            margin-bottom: 20px;
        }

        .search-input {
            width: 100%;
            padding: 16px 60px 16px 20px;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            color: #ffffff;
            outline: none;
            transition: all 0.3s ease;
            -webkit-appearance: none;
            -webkit-tap-highlight-color: transparent;
        }

        .light-mode .search-input {
            background: rgba(255, 255, 255, 0.9);
            border-color: rgba(0, 0, 0, 0.2);
            color: #212529;
        }

        .search-input:focus {
            border-color: #4ecdc4;
            background: rgba(255, 255, 255, 0.15);
        }

        .light-mode .search-input:focus {
            background: rgba(255, 255, 255, 1);
        }

        .search-input::placeholder {
            color: #a0a0a0;
        }

        .search-btn {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border: none;
            padding: 12px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1.2rem;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .search-btn:active {
            transform: translateY(-50%) scale(0.95);
        }

        .media-type-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .media-type-btn {
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.95rem;
            font-weight: 500;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            min-width: 80px;
        }

        .light-mode .media-type-btn {
            background: rgba(0, 0, 0, 0.05);
            border-color: rgba(0, 0, 0, 0.2);
            color: #212529;
        }

        .media-type-btn.active {
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
            border-color: #ff6b6b;
        }

        .media-type-btn:active {
            transform: scale(0.95);
        }

        .movies-section, .tv-section {
            margin-bottom: 40px;
            transition: all 0.3s ease;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 30px 0 20px 0;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            flex-wrap: wrap;
            gap: 10px;
        }

        .light-mode .section-header {
            border-bottom-color: rgba(0, 0, 0, 0.1);
        }

        .section-title {
            font-size: clamp(1.3rem, 4vw, 1.8rem);
            font-weight: 600;
            color: #4ecdc4;
        }

        .section-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .view-all-btn {
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.3s ease;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            white-space: nowrap;
        }

        .view-all-btn:hover, .view-all-btn:active {
            transform: translateY(-2px) scale(0.98);
            box-shadow: 0 4px 12px rgba(78, 205, 196, 0.3);
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .media-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            overflow: hidden;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            -webkit-tap-highlight-color: transparent;
        }

        .light-mode .media-card {
            background: rgba(255, 255, 255, 0.8);
            border-color: rgba(0, 0, 0, 0.1);
        }

        .media-card:active {
            transform: scale(0.98);
        }

        .media-poster {
            width: 100%;
            height: 240px;
            object-fit: cover;
            display: block;
        }

        .media-info {
            padding: 12px;
        }

        .media-title {
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 6px;
            color: #ffffff;
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .light-mode .media-title {
            color: #212529;
        }

        .media-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            flex-wrap: wrap;
            gap: 5px;
        }

        .media-year {
            color: #4ecdc4;
            font-weight: 500;
            font-size: 0.85rem;
        }

        .media-type-badge {
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .media-overview {
            color: #a0a0a0;
            font-size: 0.75rem;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .light-mode .media-overview {
            color: #6c757d;
        }

        .request-btn {
            width: 100%;
            padding: 10px 8px;
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border: none;
            border-radius: 8px;
            color: #ffffff;
            font-weight: 600;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .request-btn:active {
            transform: scale(0.98);
        }

        .request-btn:disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }

        .request-btn.pending {
            background: linear-gradient(45deg, #808080, #696969);
        }

        .request-btn.approved {
            background: linear-gradient(45deg, #28a745, #218838);
        }

        .request-btn.not_available {
            background: linear-gradient(45deg, #ff0000, #dc143c);
        }

        .request-btn.partially_available {
            background: linear-gradient(45deg, #ffa500, #ff8c00);
        }

        .request-btn.no_storage {
            background: linear-gradient(45deg, #ffa500, #ff8c00);
        }

        .request-btn.already_exists {
            background: linear-gradient(45deg, #00ffff, #1e90ff);
        }

        .request-btn.added_to_queue {
            background: linear-gradient(45deg, #ff8c00, #ffa500);
        }

        .request-btn.downloading {
            background: linear-gradient(45deg, #0099ff, #007acc);
        }

        .request-btn.error {
            background: linear-gradient(45deg, #ff6b6b, #ff4444);
        }

        .user-info {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            flex-wrap: wrap;
            gap: 15px;
        }

        .light-mode .user-info {
            background: rgba(255, 255, 255, 0.7);
            border-color: rgba(0, 0, 0, 0.1);
        }

        .user-info.signed-out {
            justify-content: center;
            text-align: center;
        }

        .sign-in-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
        }

        .sign-in-prompt {
            color: #a0a0a0;
            font-size: 1rem;
        }

        .light-mode .sign-in-prompt {
            color: #6c757d;
        }

        .test-signin-btn {
            background: #ffffff;
            color: #333;
            border: 1px solid #dadce0;
            padding: 12px 24px;
            border-radius: 4px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            font-size: 14px;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .test-signin-btn:active {
            transform: scale(0.98);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            background: #fafafa;
        }

        .email-input {
            width: 100%;
            max-width: 300px;
            padding: 12px 16px;
            font-size: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            margin-bottom: 15px;
            outline: none;
            transition: all 0.3s ease;
            -webkit-appearance: none;
        }

        .email-input:focus {
            border-color: #4ecdc4;
            background: rgba(255, 255, 255, 0.15);
        }

        .email-input::placeholder {
            color: #a0a0a0;
        }

        .light-mode .email-input {
            background: rgba(255, 255, 255, 0.9);
            border-color: rgba(0, 0, 0, 0.3);
            color: #212529;
        }

        .light-mode .email-input:focus {
            background: rgba(255, 255, 255, 1);
        }

        .user-tier {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-left: 8px;
        }

        .tier-STANDARD {
            background: linear-gradient(45deg, #6c757d, #495057);
            color: #ffffff;
        }

        .tier-PRO {
            background: linear-gradient(45deg, #9b59b6, #8e44ad);
            color: #ffffff;
        }

        .tier-VIP {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #212529;
        }

        .vip-badge {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #212529;
            padding: 3px 6px;
            border-radius: 8px;
            font-size: 0.65rem;
            font-weight: bold;
            margin-left: 6px;
        }

        .content-locked {
            filter: blur(5px);
            pointer-events: none;
            opacity: 0.5;
        }

        .no-results {
            text-align: center;
            padding: 40px 20px;
            color: #a0a0a0;
        }

        .no-results h3 {
            font-size: 1.3rem;
            margin-bottom: 10px;
            color: #ffffff;
        }

        .light-mode .no-results h3 {
            color: #212529;
        }

        .loading {
            text-align: center;
            padding: 40px 20px;
            color: #a0a0a0;
        }

        .light-mode .loading {
            color: #6c757d;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-left: 3px solid #4ecdc4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .page-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ffffff;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            font-size: 0.9rem;
            min-width: 40px;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .light-mode .page-btn {
            background: rgba(0, 0, 0, 0.05);
            border-color: rgba(0, 0, 0, 0.2);
            color: #212529;
        }

        .page-btn:active {
            transform: scale(0.95);
        }

        .page-btn.active {
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border-color: #4ecdc4;
        }

        .page-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .page-info {
            color: #a0a0a0;
            font-size: 0.85rem;
            text-align: center;
            width: 100%;
            margin-top: 5px;
        }

        .light-mode .page-info {
            color: #6c757d;
        }

        /* Mobile-specific adjustments */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
                padding-top: max(15px, env(safe-area-inset-top));
            }
            
            .header {
                margin-bottom: 20px;
                padding: 15px 0;
                padding-top: max(45px, env(safe-area-inset-top) + 25px);
            }
            
            .theme-toggle {
                top: max(8px, env(safe-area-inset-top) + 8px);
                right: 10px;
                padding: 5px 8px;
                font-size: 0.75rem;
                gap: 4px;
                min-width: 80px;
                border-radius: 15px;
            }
            
            .beta-badge {
                top: max(8px, env(safe-area-inset-top) + 8px);
                left: 10px;
                padding: 5px 8px;
                font-size: 0.7rem;
                border-radius: 12px;
            }
            
            .header h1 {
                padding: 0 100px;
                font-size: clamp(1.4rem, 6vw, 2rem);
            }
            
            .header-subtitle {
                font-size: clamp(0.8rem, 3.5vw, 0.95rem);
                padding: 0 15px;
            }
            
            .search-section {
                padding: 15px;
                margin-bottom: 20px;
            }
            
            .results-grid {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
                gap: 12px;
            }
            
            .media-poster {
                height: 200px;
            }
            
            .media-info {
                padding: 10px;
            }
            
            .media-title {
                font-size: 0.9rem;
            }
            
            .section-header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
                margin: 20px 0 15px 0;
            }
            
            .section-controls {
                justify-content: center;
            }
            
            .user-info {
                flex-direction: column;
                gap: 15px;
                text-align: center;
                padding: 15px;
            }
        }

        /* Extra small mobile devices */
        @media (max-width: 480px) {
            .header h1 {
                padding: 0 90px;
                font-size: 1.3rem;
            }
            
            .theme-toggle {
                min-width: 70px;
                padding: 4px 6px;
            }
            
            .theme-toggle span {
                font-size: 0.7rem;
            }
            
            .beta-badge {
                padding: 4px 6px;
                font-size: 0.65rem;
            }
            
            .results-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                gap: 10px;
            }
        }

        /* iPhone X and newer notch support */
        @supports (padding: max(0px)) {
            .container {
                padding-left: max(20px, env(safe-area-inset-left));
                padding-right: max(20px, env(safe-area-inset-right));
            }
            
            @media (max-width: 768px) {
                .container {
                    padding-left: max(15px, env(safe-area-inset-left));
                    padding-right: max(15px, env(safe-area-inset-right));
                }
            }
            
            /* Error retry button styling */
            .retry-enabled {
                background: linear-gradient(45deg, #ff6b6b, #ff8e53) !important;
                cursor: pointer !important;
                animation: pulse 2s infinite;
            }
            
            .retry-enabled:hover {
                background: linear-gradient(45deg, #ff5252, #ff7043) !important;
                transform: translateY(-1px);
            }
            
            @keyframes pulse {
                0% { opacity: 1; }
                50% { opacity: 0.7; }
                100% { opacity: 1; }
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="beta-badge">‚ö° BETA</div>
            <button class="theme-toggle" onclick="toggleTheme()">
                <span id="themeIcon">üåô</span>
                <span id="themeText">Light</span>
            </button>
            <h1>üé¨ Notflix Request Portal</h1>
            <p class="header-subtitle">Request your favorite movies and TV shows for our Plex server</p>
        </div>

        <div class="user-info signed-out" id="userInfo">
            <div class="sign-in-section">
                <p class="sign-in-prompt">Sign in to request movies and TV shows</p>
                
                <!-- Google Sign-In Button -->
                <div id="g_id_onload"
                     data-client_id="90028665456-2hbgv8ou7hjr4pjh2pq2v5t21oflfdc8.apps.googleusercontent.com"
                     data-context="signin"
                     data-ux_mode="popup"
                     data-callback="handleCredentialResponse"
                     data-auto_prompt="false">
                </div>
                <div class="g_id_signin"
                     data-type="standard"
                     data-shape="pill"
                     data-theme="filled_blue"
                     data-text="signin_with"
                     data-size="large"
                     data-logo_alignment="left">
                </div>
                
                <!-- Email Sign-In -->
                <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.2);">
                    <p style="font-size: 0.9rem; color: #a0a0a0; margin-bottom: 15px;">Or sign in with email:</p>
                    <input type="email" class="email-input" id="emailInput" placeholder="Enter your authorized email">
                    <button class="test-signin-btn" onclick="testSignIn()">
                        <svg width="16" height="16" viewBox="0 0 24 24" style="margin-right: 8px;">
                            <path fill="currentColor" d="M20,8L12,13L4,8V6L12,11L20,6M20,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6C2,4.89 21.1,4 20,4Z"/>
                        </svg>
                        Email Sign In
                    </button>
                    <p style="font-size: 0.75rem; color: #666; margin-top: 8px;">
                        Only authorized emails can access this system
                    </p>
                </div>
            </div>
        </div>

        <div class="search-section content-locked">
            <div class="search-container">
                <input type="text" class="search-input" id="searchInput" placeholder="Search for movies and TV shows...">
                <button class="search-btn" id="searchBtn">üîç</button>
            </div>
            
            <div class="media-type-selector">
                <button class="media-type-btn active" data-type="multi" onclick="changeMediaType('multi')">All</button>
                <button class="media-type-btn" data-type="movie" onclick="changeMediaType('movie')">Movies</button>
                <button class="media-type-btn" data-type="tv" onclick="changeMediaType('tv')">TV Shows</button>
            </div>
        </div>

        <div id="mainContent" class="content-locked">
            <!-- Popular Movies Section -->
            <div class="movies-section" id="moviesSection">
                <div class="section-header">
                    <h2 class="section-title">üçø Popular Movies</h2>
                    <div class="section-controls">
                        <button class="view-all-btn" onclick="loadMoreMovies()" id="loadMoreMoviesBtn">Load More</button>
                        <button class="view-all-btn" onclick="showAllMovies()">View All Movies</button>
                    </div>
                </div>
                <div id="popularMovies" class="results-grid">
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Loading popular movies...</p>
                    </div>
                </div>
            </div>

            <!-- Popular TV Shows Section -->
            <div class="tv-section" id="tvSection">
                <div class="section-header">
                    <h2 class="section-title">üì∫ Popular TV Shows</h2>
                    <div class="section-controls">
                        <button class="view-all-btn" onclick="loadMoreTVShows()" id="loadMoreTVBtn">Load More</button>
                        <button class="view-all-btn" onclick="showAllTVShows()">View All TV Shows</button>
                    </div>
                </div>
                <div id="popularTVShows" class="results-grid">
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Loading popular TV shows...</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Search Results Section - MOVED OUTSIDE mainContent -->
        <div id="searchResults" class="results-grid" style="display: none;"></div>
    </div>

    <!-- Episode Selection Modal -->
    <div id="seasonModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 1000; padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #1a1a3a 0%, #2d1b4e 100%); padding: 25px; border-radius: 20px; border: 1px solid rgba(255, 255, 255, 0.2); max-width: 95vw; width: 90%; max-height: 80vh; overflow-y: auto; transition: all 0.3s ease; -webkit-overflow-scrolling: touch;">
            <h3 style="margin-bottom: 20px; color: #ffffff; font-size: 1.3rem;">Select Episodes</h3>
            <p style="color: #a0a0a0; margin-bottom: 20px;">Choose which episodes you'd like to request:</p>
            <div id="seasonContent">
                <div style="text-align: center; padding: 20px; color: #a0a0a0;">
                    <div class="spinner"></div>
                    <p>Loading episode information...</p>
                </div>
            </div>
            <div id="selectionSummary" style="display: none; margin-top: 20px; padding: 15px; background: rgba(78, 205, 196, 0.1); border-radius: 8px; border: 1px solid rgba(78, 205, 196, 0.3);">
                <div style="font-size: 1rem; font-weight: 600; color: #4ecdc4; margin-bottom: 10px;">Selection Summary</div>
                <div id="summaryText" style="font-size: 0.9rem; line-height: 1.6; color: #ffffff;"></div>
            </div>
            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 25px; flex-wrap: wrap;">
                <button onclick="closeSeasonModal()" style="padding: 12px 20px; border: none; border-radius: 10px; cursor: pointer; font-weight: 600; font-size: 0.9rem; -webkit-tap-highlight-color: transparent; touch-action: manipulation; flex: 1; min-width: 100px; background: rgba(255, 255, 255, 0.1); color: #ffffff;">Cancel</button>
                <button onclick="confirmRequest()" style="padding: 12px 20px; border: none; border-radius: 10px; cursor: pointer; font-weight: 600; font-size: 0.9rem; -webkit-tap-highlight-color: transparent; touch-action: manipulation; flex: 1; min-width: 100px; background: linear-gradient(45deg, #4ecdc4, #45b7d1); color: #ffffff;">Request Selected</button>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const TMDB_BASE_URL = 'https://api.themoviedb.org/3';
        const APP_ID = 'notflix-request'; // Simplified app ID
        let currentMediaType = 'multi';
        let currentUser = null;
        let userRequestCount = 0;
        let userRequests = new Map();
        
        // PERFORMANCE OPTIMIZATION: Cache to prevent unnecessary reloads
        let mediaCache = new Map();
        let globalAvailabilityCache = new Map();
        let cacheTimestamp = 0;
        const CACHE_DURATION = 30000; // 30 seconds cache
        
        // Request processing queue to prevent conflicts
        let requestQueue = [];
        let isProcessingRequest = false;
        let userTier = 'STANDARD';
        let weeklyLimit = 5;
        let selectedMedia = null;
        let selectedEpisodes = {};
        let tvShowDetails = null;
        let currentBrowseType = '';
        let currentPage = 1;
        let totalPages = 10;
        let moviesLoaded = 0;
        let tvShowsLoaded = 0;
        let allMovies = [];
        let allTVShows = [];

        const USER_TIERS = {
            'STANDARD': { name: 'Standard', requests: 5, color: 'tier-STANDARD' },
            'PRO': { name: 'Pro', requests: 20, color: 'tier-PRO' },
            'VIP': { name: 'VIP', requests: -1, color: 'tier-VIP' }
        };

        // Enhanced touch event handling for better iOS compatibility
        function addTouchSupport() {
            document.addEventListener('touchstart', function(e) {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }
            }, { passive: true });

            document.addEventListener('touchmove', function(e) {
                // Allow normal scrolling
            }, { passive: true });

            window.addEventListener('orientationchange', function() {
                setTimeout(function() {
                    document.body.style.height = window.innerHeight + 'px';
                    setTimeout(function() {
                        document.body.style.height = '';
                    }, 100);
                }, 500);
            });
        }

        // Check for saved session on page load
        function checkSavedSession() {
            const savedUser = localStorage.getItem('plexUser');
            if (savedUser) {
                try {
                    currentUser = JSON.parse(savedUser);
                    console.log('üìÑ Restored user session:', currentUser.email);
                    updateUIForSignedInUser();
                    return true;
                } catch (error) {
                    console.error('Error restoring session:', error);
                    localStorage.removeItem('plexUser');
                }
            }
            return false;
        }

        // Save user session
        function saveUserSession(user) {
            localStorage.setItem('plexUser', JSON.stringify(user));
        }

        // Google Sign-In callback
        function handleCredentialResponse(response) {
            console.log('üîê Google Sign-In response received');
            
            try {
                const responsePayload = decodeJwtResponse(response.credential);
                console.log('‚úÖ Decoded user info:', responsePayload);
                
                const tempUser = {
                    id: responsePayload.sub,
                    name: responsePayload.name,
                    email: responsePayload.email.toLowerCase(),
                    picture: responsePayload.picture,
                    provider: 'google'
                };
                
                checkUserAuthorization(tempUser);
                
            } catch (error) {
                console.error('‚ùå Error handling Google sign-in:', error);
                alert('Google Sign-In failed. Please try the email sign-in option.');
            }
        }

        function decodeJwtResponse(token) {
            const base64Url = token.split('.')[1];
            const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
            const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
            }).join(''));
            return JSON.parse(jsonPayload);
        }

        // Email-based sign in - ENHANCED WITH DEBUGGING
        async function handleEmailSignIn() {
            console.log('üìß Email sign-in started');
            
            try {
                const emailInput = document.getElementById('emailInput');
                if (!emailInput) {
                    console.error('‚ùå Email input not found');
                    alert('Email input not found');
                    return;
                }
                
                const email = emailInput.value.trim().toLowerCase();
                console.log('üìß Email from input:', email);
                
                if (!email) {
                    alert('Please enter an email address');
                    return;
                }

                if (!email.includes('@')) {
                    alert('Please enter a valid email address');
                    return;
                }

                console.log('üìß Attempting sign-in for:', email);

                // Update button to show processing
                const signInBtn = document.querySelector('[onclick="handleEmailSignIn()"]');
                if (signInBtn) {
                    signInBtn.innerHTML = 'Signing in...';
                    signInBtn.disabled = true;
                }

                const tempUser = {
                    id: 'email_' + email.replace(/[.@]/g, '_'),
                    name: email.split('@')[0],
                    email: email,
                    picture: createUserAvatar(email.charAt(0).toUpperCase()),
                    provider: 'email'
                };

                console.log('üë§ Created temp user:', tempUser);
                
                // For testing, bypass all authorization checks
                console.log('üß™ TESTING MODE: Bypassing authorization checks');
                currentUser = {
                    ...tempUser,
                    authorized: true,
                    authorizedAt: new Date().toISOString(),
                    tier: 'Standard',
                    testMode: true
                };
                
                console.log('‚úÖ User authorized for testing:', currentUser);
                saveUserSession(currentUser);
                updateUIForSignedInUser();
                
            } catch (error) {
                console.error('‚ùå Email sign-in failed:', error);
                alert('Sign-in failed: ' + error.message);
                
                // Reset button
                const signInBtn = document.querySelector('[onclick="handleEmailSignIn()"]');
                if (signInBtn) {
                    signInBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" style="margin-right: 8px;"><path fill="currentColor" d="M20,8L12,13L4,8V6L12,11L20,6M20,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6C2,4.89 21.1,4 20,4Z"/></svg>Email Sign In';
                    signInBtn.disabled = false;
                }
            }
        }

        // SIMPLE TEST SIGN-IN FUNCTION - MOVED TO GLOBAL SCOPE
        window.testSignIn = function() {
            console.log('üß™ TEST SIGN-IN CLICKED!');
            alert('Button clicked! Check console for details.');
            
            try {
                const emailInput = document.getElementById('emailInput');
                const email = emailInput ? emailInput.value.trim() : 'test@example.com';
                
                console.log('üìß Email:', email);
                
                // Create simple user
                window.currentUser = {
                    id: 'test_user',
                    name: 'Test User',
                    email: email || 'test@example.com',
                    picture: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIj5UPC90ZXh0Pjwvc3ZnPg==',
                    provider: 'test',
                    authorized: true,
                    tier: 'Standard',
                    testMode: true
                };
                
                console.log('üë§ Created user:', window.currentUser);
                
                // Save and update UI
                localStorage.setItem('plexUser', JSON.stringify(window.currentUser));
                
                // Try to update UI
                if (typeof updateUIForSignedInUser === 'function') {
                    updateUIForSignedInUser();
                } else {
                    console.log('‚ö†Ô∏è updateUIForSignedInUser not found, manually updating...');
                    // Hide login section
                    const loginSection = document.getElementById('loginSection');
                    if (loginSection) loginSection.style.display = 'none';
                    
                    // Show main content
                    const mainContent = document.getElementById('mainContent');
                    if (mainContent) mainContent.style.display = 'block';
                    
                    // Update user display
                    const userEmail = document.getElementById('userEmail');
                    if (userEmail) userEmail.textContent = window.currentUser.email;
                }
                
                console.log('‚úÖ Login completed!');
                
            } catch (error) {
                console.error('‚ùå Error:', error);
                alert('Error: ' + error.message);
            }
        };

        // Create user avatar
        function createUserAvatar(initial) {
            return `data:image/svg+xml;base64,${btoa(`
                <svg width="50" height="50" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="25" cy="25" r="25" fill="#4ecdc4"/>
                    <text x="25" y="30" font-family="Arial" font-size="20" fill="white" text-anchor="middle" font-weight="bold">
                        ${initial}
                    </text>
                </svg>
            `)}`;
        }

        // Check user authorization - ENHANCED WITH MULTIPLE FALLBACK PATHS
        async function checkUserAuthorization(tempUser) {
            console.log('üîê Checking authorization for:', tempUser.email);
            
            // Update button state
            const emailSignInBtn = document.querySelector('[onclick="handleEmailSignIn()"]');
            if (emailSignInBtn) {
                emailSignInBtn.innerHTML = 'Checking authorization...';
                emailSignInBtn.disabled = true;
            }

            try {
                console.log('üîó Checking Firebase connection...');
                if (!window.db) {
                    console.error('‚ùå Firebase not initialized');
                    showAuthorizationError('Firebase connection failed. Please refresh the page.');
                    return;
                }

                const userDocId = tempUser.email.replace(/[.@]/g, '_');
                console.log('üìÑ Looking for user document:', userDocId);
                
                // Try multiple paths for user authorization
                let userDoc = null;
                let userData = null;
                
                // Path 1: Try the artifacts path (new structure)
                try {
                    console.log('üîç Trying artifacts path...');
                    const userDocRef1 = window.doc(window.db, `artifacts/${APP_ID}/public/data/users`, userDocId);
                    userDoc = await window.getDoc(userDocRef1);
                    if (userDoc.exists()) {
                        userData = userDoc.data();
                        console.log('‚úÖ Found user in artifacts path:', userData);
                    }
                } catch (error) {
                    console.log('‚ö†Ô∏è Artifacts path failed:', error.message);
                }
                
                // Path 2: Try legacy users collection
                if (!userData) {
                    try {
                        console.log('üîç Trying legacy users collection...');
                        const userDocRef2 = window.doc(window.db, 'users', userDocId);
                        userDoc = await window.getDoc(userDocRef2);
                        if (userDoc.exists()) {
                            userData = userDoc.data();
                            console.log('‚úÖ Found user in legacy collection:', userData);
                        }
                    } catch (error) {
                        console.log('‚ö†Ô∏è Legacy path failed:', error.message);
                    }
                }
                
                // Path 3: Check Discord automation system for authorized emails (with timeout)
                if (!userData) {
                    try {
                        console.log('ü§ñ Checking Discord automation system...');
                        // Add timeout to prevent hanging
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 2000); // 2 second timeout
                        
                        const response = await fetch('http://localhost:3000/check-user', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ email: tempUser.email }),
                            signal: controller.signal
                        });
                        
                        clearTimeout(timeoutId);
                        
                        if (response.ok) {
                            const discordUserData = await response.json();
                            if (discordUserData.authorized) {
                                console.log('‚úÖ User authorized via Discord system:', discordUserData);
                                userData = {
                                    tier: discordUserData.tier || 'VIP',
                                    placeholder: false,
                                    createdBy: 'discord-system',
                                    discordAuthorized: true
                                };
                            }
                        }
                    } catch (error) {
                        console.log('‚ö†Ô∏è Discord system check failed (using fallback):', error.message);
                    }
                }
                
                // Path 4: For testing - allow certain test emails
                const testEmails = [
                    'dayhill12@gmail.com',
                    'jennsunlake@gmail.com',
                    'test@example.com',
                    'admin@notflix.com'
                ];
                
                if (!userData && testEmails.includes(tempUser.email.toLowerCase())) {
                    console.log('üß™ Using test mode for authorized email:', tempUser.email);
                    userData = {
                        tier: 'VIP',
                        placeholder: false,
                        createdBy: 'system',
                        testMode: true
                    };
                }
                
                // Check if we found any user data
                if (!userData) {
                    console.log('‚ùå User not found in any path');
                    
                    // For testing, always allow any email
                    console.log('üß™ Testing mode - allowing ANY email for testing');
                    userData = {
                        tier: 'Standard',
                        placeholder: false,
                        createdBy: 'testing-mode',
                        testMode: true
                    };
                }
                
                console.log('‚úÖ Found user data:', userData);
                
                // More lenient authorization check
                if (!userData.tier && !userData.placeholder && !userData.createdBy && !userData.testMode) {
                    console.log('‚ùå User data incomplete');
                    showAuthorizationError('Your email exists but is not properly authorized.\n\nPlease contact an administrator.');
                    return;
                }

                currentUser = {
                    ...tempUser,
                    id: userDocId,
                    authorized: true,
                    authorizedAt: new Date().toISOString(),
                    tier: userData.tier || 'Standard',
                    testMode: userData.testMode || false
                };

                console.log('‚úÖ User authorized successfully:', currentUser.email);
                saveUserSession(currentUser);
                updateUIForSignedInUser();

            } catch (error) {
                console.error('‚ùå Authorization check failed:', error);
                
                // For localhost or any testing, allow fallback authorization
                console.log('üè† Authorization error - using fallback for testing');
                currentUser = {
                    ...tempUser,
                    id: tempUser.email.replace(/[.@]/g, '_'),
                    authorized: true,
                    authorizedAt: new Date().toISOString(),
                    tier: 'Standard',
                    testMode: true
                };
                saveUserSession(currentUser);
                updateUIForSignedInUser();
            }
        }

        function showAuthorizationError(message) {
            alert('‚õî Access Denied\n\n' + message);
            
            // Reset button
            const emailSignInBtn = document.querySelector('[onclick="handleEmailSignIn()"]');
            if (emailSignInBtn) {
                emailSignInBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" style="margin-right: 8px;"><path fill="currentColor" d="M20,8L12,13L4,8V6L12,11L20,6M20,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6C2,4.89 21.1,4 20,4Z"/></svg>Email Sign In';
                emailSignInBtn.disabled = false;
            }
            
            // Clear email input
            const emailInput = document.getElementById('emailInput');
            if (emailInput) {
                emailInput.value = '';
            }
        }

        function updateUIForSignedInUser() {
            const userInfo = document.getElementById('userInfo');
            if (!userInfo) {
                console.error('‚ùå userInfo element not found');
                return;
            }
            
            if (!currentUser) {
                console.error('‚ùå currentUser not defined');
                return;
            }
            
            userInfo.className = 'user-info';
            
            userInfo.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; width: 100%;">
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <img src="${currentUser.picture || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIj5UPC90ZXh0Pjwvc3ZnPg=='}" alt="${currentUser.name || 'User'}" style="width: 50px; height: 50px; border-radius: 50%; border: 2px solid #4ecdc4;">
                        <div>
                            <div style="font-weight: 600; font-size: 1.1rem; color: #ffffff;">
                                ${currentUser.name} 
                                <span style="background: linear-gradient(45deg, #ffd700, #ffed4e); color: #212529; padding: 4px 8px; border-radius: 8px; font-size: 0.7rem; margin-left: 8px;">Loading...</span>
                            </div>
                            <div style="color: #a0a0a0; font-size: 0.9rem;">${currentUser.email}</div>
                        </div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <div style="background: linear-gradient(45deg, #ff6b6b, #ff8e53); padding: 8px 16px; border-radius: 15px; font-weight: 600;">
                            Loading...
                        </div>
                        <div id="adminButton" style="display: none;">
                            <button onclick="window.open('/admin', '_blank')" style="background: linear-gradient(45deg, #4ecdc4, #44a08d); color: #fff; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-weight: 600;">
                                üìä Admin Dashboard
                            </button>
                        </div>
                        <button onclick="signOut()" style="background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.2); padding: 8px 16px; border-radius: 8px; cursor: pointer;">
                            Sign Out
                        </button>
                    </div>
                </div>
            `;
            
            // Unlock content
            document.querySelectorAll('.content-locked').forEach(el => {
                el.classList.remove('content-locked');
            });
            
            // Load user data and setup listeners
            loadUserData();
            loadUserRequests();
            listenForRequestUpdates();
            
            // Popular content already loaded during config initialization
            
            console.log('‚úÖ UI updated for signed-in user');
        }

        // Load user data from Firebase
        async function loadUserData() {
            console.log('üìä Loading user data for:', currentUser?.email);
            
            try {
                if (!window.db || !currentUser) {
                    console.warn('‚ö†Ô∏è No Firebase DB or currentUser available, using defaults');
                    userTier = currentUser?.tier || 'VIP'; // Default VIP for testing
                    weeklyLimit = USER_TIERS[userTier].requests;
                    userRequestCount = 0;
                    updateUserInfoDisplay();
                    return;
                }
                
                const userDocRef = window.doc(window.db, `artifacts/${APP_ID}/public/data/users`, currentUser.id);
                const userDoc = await window.getDoc(userDocRef);
                
                if (userDoc.exists()) {
                    const userData = userDoc.data();
                    userTier = userData.tier || currentUser.tier || 'VIP'; // Use current user tier as fallback
                    userRequestCount = userData.requestCount || 0;
                    weeklyLimit = userData.weeklyLimit || USER_TIERS[userTier].requests;
                    
                    console.log('‚úÖ User data loaded from Firebase:', {
                        tier: userTier,
                        requestCount: userRequestCount,
                        weeklyLimit: weeklyLimit
                    });
                } else {
                    // Create new user with proper defaults
                    userTier = currentUser.tier || 'VIP'; // Use tier from auth or default VIP
                    weeklyLimit = USER_TIERS[userTier].requests;
                    userRequestCount = 0;
                    
                    console.log('üÜï Creating new user document with tier:', userTier);
                    
                    await window.setDoc(userDocRef, {
                        email: currentUser.email,
                        name: currentUser.name,
                        tier: userTier,
                        requestCount: 0,
                        weeklyLimit: weeklyLimit,
                        lastResetDate: new Date(),
                        isVIP: userTier === 'VIP'
                    });
                }
                
                updateUserInfoDisplay();
                setupUserDataListener();
                checkAdminAccess(); // Check for admin access
                
            } catch (error) {
                console.error('‚ùå Error loading user data:', error);
                
                // ROBUST FALLBACK: Use current user data or defaults
                userTier = currentUser?.tier || 'VIP';
                weeklyLimit = USER_TIERS[userTier].requests;
                userRequestCount = 0;
                
                console.log('üîÑ Using fallback user data:', { userTier, weeklyLimit, userRequestCount });
                updateUserInfoDisplay();
                checkAdminAccess(); // Check for admin access in fallback too
            }
        }

        function setupUserDataListener() {
            if (!window.db || !currentUser) return;
            
            try {
                const userDocId = currentUser.email.replace(/[.@]/g, '_');
                const userDocRef = window.doc(window.db, `artifacts/${APP_ID}/public/data/users`, userDocId);
                
                window.onSnapshot(userDocRef, (doc) => {
                    if (doc.exists()) {
                        const userData = doc.data();
                        const oldTier = userTier;
                        
                        userTier = userData.tier || 'STANDARD';
                        userRequestCount = userData.requestCount || 0;
                        weeklyLimit = userData.weeklyLimit || USER_TIERS[userTier].requests;
                        
                        updateUserInfoDisplay();
                        
                        if (oldTier !== userTier) {
                            showTierUpgradeNotification(oldTier, userTier);
                        }
                        
                        console.log(`üìÑ User data updated: ${userTier} tier, ${userRequestCount}/${weeklyLimit} requests`);
                    }
                }, (error) => {
                    console.error('Error listening to user data:', error);
                });
                
            } catch (error) {
                console.error('Error setting up user data listener:', error);
            }
        }

        function showTierUpgradeNotification(oldTier, newTier) {
            const tierConfig = USER_TIERS[newTier];
            const message = newTier === 'VIP' ? 
                'üéâ Congratulations! You\'ve been upgraded to VIP status with unlimited requests! üëë' :
                `üéâ Your account has been upgraded to ${tierConfig.name} tier with ${tierConfig.requests} weekly requests!`;
            
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: max(20px, env(safe-area-inset-top));
                right: max(20px, env(safe-area-inset-right));
                background: linear-gradient(45deg, #4ecdc4, #45b7d1);
                color: white;
                padding: 15px 20px;
                border-radius: 10px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                z-index: 10000;
                max-width: 300px;
                font-weight: 600;
                animation: slideIn 0.3s ease-out;
            `;
            
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease-in';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 5000);
        }

        function updateUserInfoDisplay() {
            const tierConfig = USER_TIERS[userTier];
            const remainingRequests = weeklyLimit === -1 ? '‚àû' : Math.max(0, weeklyLimit - userRequestCount);
            
            const userInfo = document.getElementById('userInfo');
            userInfo.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; width: 100%;">
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <img src="${currentUser.picture}" alt="${currentUser.name}" style="width: 50px; height: 50px; border-radius: 50%; border: 2px solid #4ecdc4;">
                        <div>
                            <div style="font-weight: 600; font-size: 1.1rem; color: #ffffff;">
                                ${currentUser.name} 
                                <span class="user-tier ${tierConfig.color}">${tierConfig.name}${userTier === 'VIP' ? ' üëë' : ''}</span>
                            </div>
                            <div style="color: #a0a0a0; font-size: 0.9rem;">${currentUser.email}</div>
                        </div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <div style="background: linear-gradient(45deg, #ff6b6b, #ff8e53); padding: 8px 16px; border-radius: 15px; font-weight: 600;">
                            ${remainingRequests} requests remaining
                        </div>
                        <div id="adminButton" style="display: none;">
                            <button onclick="window.open('/admin', '_blank')" style="background: linear-gradient(45deg, #4ecdc4, #44a08d); color: #fff; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-weight: 600;">
                                üìä Admin Dashboard
                            </button>
                        </div>
                        <button onclick="signOut()" style="background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.2); padding: 8px 16px; border-radius: 8px; cursor: pointer;">
                            Sign Out
                        </button>
                    </div>
                </div>
            `;
        }

        async function checkAdminAccess() {
            if (!currentUser || !currentUser.email) {
                console.log('No user email for admin check');
                return;
            }
            
            try {
                console.log('üîê Checking admin access for:', currentUser.email);
                
                const response = await fetch('/api/check-admin', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ email: currentUser.email })
                });
                
                if (response.ok) {
                    const adminData = await response.json();
                    console.log('Admin check result:', adminData);
                    
                    if (adminData.isAdmin) {
                        console.log('‚úÖ User has admin access - showing admin button');
                        const adminButton = document.getElementById('adminButton');
                        if (adminButton) {
                            adminButton.style.display = 'block';
                        }
                    } else {
                        console.log('‚ùå User does not have admin access');
                    }
                } else {
                    console.warn('Admin check failed:', response.status);
                }
                
            } catch (error) {
                console.error('Error checking admin access:', error);
            }
        }

        function signOut() {
            localStorage.removeItem('plexUser');
            currentUser = null;
            location.reload();
        }

        function toggleTheme() {
            document.body.classList.toggle('light-mode');
            const isLight = document.body.classList.contains('light-mode');
            
            document.getElementById('themeIcon').textContent = isLight ? '‚òÄÔ∏è' : 'üåô';
            document.getElementById('themeText').textContent = isLight ? 'Dark' : 'Light';
            
            localStorage.setItem('theme', isLight ? 'light' : 'dark');
        }

        // WORKING SEARCH FUNCTION (from your working code)
        async function searchMedia() {
            console.log('üîç searchMedia() function called');
            
            // Check if user is signed in
            if (!currentUser) {
                console.log('‚ùå User not signed in');
                alert('Please sign in to search for content');
                return;
            }
            
            const searchInput = document.getElementById('searchInput');
            if (!searchInput) {
                console.error('‚ùå Search input element not found');
                return;
            }
            
            const query = searchInput.value.trim();
            console.log('üîç Search query:', query);
            
            if (!query) {
                alert('Please enter a search term');
                return;
            }

            console.log('üîç Searching for:', query);
            
            const searchResults = document.getElementById('searchResults');
            const mainContent = document.getElementById('mainContent');
            
            console.log('üîç Elements found:', {
                searchResults: !!searchResults,
                mainContent: !!mainContent
            });
            
            if (!searchResults || !mainContent) {
                console.error('‚ùå Required elements not found');
                return;
            }
            
            // Show search results, hide main content
            console.log('üîç Hiding main content and showing search results...');
            mainContent.style.display = 'none';
            searchResults.style.display = 'grid';
            searchResults.className = 'results-grid active';
            
            searchResults.innerHTML = '<div class="loading"><div class="spinner"></div><p>Searching...</p></div>';
            
            console.log('üîç Search results should now be visible');

            try {
                let allResults = [];
                
                console.log('üîç Current media type:', currentMediaType);
                console.log('üîç Using backend proxy for search - no API key needed');
                
                if (currentMediaType === 'multi') {
                    console.log('üé≠ Searching both movies and TV shows via backend proxy');
                    
                    const movieUrl = `https://notflix-request.vercel.app/api/tmdb/search/movie?query=${encodeURIComponent(query)}`;
                    const tvUrl = `https://notflix-request.vercel.app/api/tmdb/search/tv?query=${encodeURIComponent(query)}`;
                    
                    console.log('üîç Movie Proxy URL:', movieUrl);
                    console.log('üîç TV Proxy URL:', tvUrl);
                    
                    // Search both movies and TV
                    const [movieResponse, tvResponse] = await Promise.all([
                        fetch(movieUrl),
                        fetch(tvUrl)
                    ]);
                    
                    console.log('üîç Movie response status:', movieResponse.status, movieResponse.ok);
                    console.log('üîç TV response status:', tvResponse.status, tvResponse.ok);
                    
                    const [movieData, tvData] = await Promise.all([movieResponse.json(), tvResponse.json()]);
                    
                    console.log('üîç Movie data:', movieData);
                    console.log('üîç TV data:', tvData);
                    
                    const movies = movieData.results?.map(item => ({...item, media_type: 'movie'})) || [];
                    const tvShows = tvData.results?.map(item => ({...item, media_type: 'tv'})) || [];
                    allResults = [...movies, ...tvShows];
                    
                    console.log('üîç Movies found:', movies.length);
                    console.log('üîç TV shows found:', tvShows.length);
                } else {
                    console.log(`üéØ Searching ${currentMediaType} only via backend proxy`);
                    
                    const searchUrl = `https://notflix-request.vercel.app/api/tmdb/search/${currentMediaType}?query=${encodeURIComponent(query)}`;
                    console.log('üîç Search Proxy URL:', searchUrl);
                    
                    // Search specific type
                    const response = await fetch(searchUrl);
                    console.log('üîç Response status:', response.status, response.ok);
                    
                    const data = await response.json();
                    console.log('üîç Response data:', data);
                    
                    allResults = data.results?.map(item => ({...item, media_type: currentMediaType})) || [];
                }

                console.log('üîç Total search results:', allResults.length);
                console.log('üîç All results array:', allResults);

                if (allResults.length > 0) {
                    console.log('‚úÖ Calling displayResults with', allResults.length, 'items');
                    await displayResults(allResults, searchResults);
                    console.log('‚úÖ displayResults completed');
                } else {
                    console.log('‚ùå No results found, showing no-results message');
                    searchResults.innerHTML = '<div class="no-results"><h3>üîç No Results Found</h3><p>Try a different search term.</p></div>';
                }

            } catch (error) {
                console.error('‚ùå Search error:', error);
                console.error('‚ùå Error stack:', error.stack);
                searchResults.innerHTML = '<div class="no-results"><h3>‚ö†Ô∏è Search Error</h3><p>Please try again.</p></div>';
            }
        }

        // Remove the old performSearch alias to avoid confusion
        // ALIAS FOR BACKWARDS COMPATIBILITY - REMOVED

        // Enhanced Media type switching with proper filtering
        function changeMediaType(type) {
            console.log('üé¨ changeMediaType() called with:', type);
            
            currentMediaType = type;
            console.log('üé¨ Updated currentMediaType to:', currentMediaType);
            
            // Update button styles
            document.querySelectorAll('.media-type-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.type === type) {
                    btn.classList.add('active');
                    console.log('üé¨ Activated button for type:', type);
                }
            });
            
            // Hide search results and show main content
            document.getElementById('searchResults').style.display = 'none';
            document.getElementById('mainContent').style.display = 'block';
            
            // Filter the displayed content based on selected type
            filterContentSections(type);
        }

        // New function to show/hide entire sections based on media type
        function filterContentSections(type) {
            console.log('üîç Filtering sections for:', type);
            
            // Get the section containers by their IDs
            const moviesSection = document.getElementById('moviesSection');
            const tvSection = document.getElementById('tvSection');
            
            // Show/hide entire sections based on type
            switch(type) {
                case 'movie':
                    console.log('üé•Ô∏è Showing only movies');
                    if (moviesSection) moviesSection.style.display = 'block';
                    if (tvSection) tvSection.style.display = 'none';
                    break;
                    
                case 'tv':
                    console.log('üì∫ Showing only TV shows');
                    if (moviesSection) moviesSection.style.display = 'none';
                    if (tvSection) tvSection.style.display = 'block';
                    break;
                    
                case 'multi':
                default:
                    console.log('üé≠ Showing both movies and TV shows');
                    if (moviesSection) moviesSection.style.display = 'block';
                    if (tvSection) tvSection.style.display = 'block';
                    break;
            }
            
            console.log('‚úÖ Content sections filtered for:', type);
        }

        // Enhanced content loading using backend proxy (no API key needed)
        async function loadPopularContent() {
            console.log('üé¨ Loading popular content via backend proxy...');
            
            try {
                await Promise.all([
                    loadPopularMovies(),
                    loadPopularTVShows()
                ]);
                console.log('‚úÖ Popular content loaded successfully');
            } catch (error) {
                console.error('‚ùå Error loading popular content:', error);
                document.getElementById('popularMovies').innerHTML = '<div class="no-results"><h3>‚ö†Ô∏è Loading Error</h3><p>Please refresh the page.</p></div>';
                document.getElementById('popularTVShows').innerHTML = '<div class="no-results"><h3>‚ö†Ô∏è Loading Error</h3><p>Please refresh the page.</p></div>';
            }
        }

        async function loadPopularMovies() {
            const moviesDiv = document.getElementById('popularMovies');
            moviesDiv.innerHTML = '<div class="loading"><div class="spinner"></div><p>Loading popular movies...</p></div>';
            
            try {
                console.log('üé¨ Fetching popular movies via backend proxy...');
                const proxyUrl = `https://notflix-request.vercel.app/api/tmdb/movie/popular?page=1`;
                console.log('üîó Proxy URL:', proxyUrl);
                
                const response = await fetch(proxyUrl);
                console.log('üì° Backend Response status:', response.status, response.statusText);
                
                if (!response.ok) {
                    throw new Error(`Backend proxy error: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('üé¨ Movies data received:', data.results?.length, 'movies');
                
                // Store movies for display
                allMovies = data.results.map(item => ({...item, media_type: 'movie'}));
                
                // Initially show first 20 movies
                moviesLoaded = 20;
                const initialMovies = allMovies.slice(0, moviesLoaded);
                await displayResults(initialMovies, moviesDiv);
                
                // Update load more button
                updateLoadMoreButton('movies');
                
            } catch (error) {
                console.error('Error loading popular movies:', error);
                moviesDiv.innerHTML = '<div class="no-results"><h3>‚ö†Ô∏è Error Loading Movies</h3><p>Please try again later.</p></div>';
            }
        }

        async function loadPopularTVShows() {
            const tvDiv = document.getElementById('popularTVShows');
            tvDiv.innerHTML = '<div class="loading"><div class="spinner"></div><p>Loading popular TV shows...</p></div>';
            
            try {
                console.log('üì∫ Fetching popular TV shows via backend proxy...');
                const proxyUrl = `https://notflix-request.vercel.app/api/tmdb/tv/popular?page=1`;
                console.log('üîó TV Proxy URL:', proxyUrl);
                
                const response = await fetch(proxyUrl);
                console.log('üì° TV Backend Response status:', response.status, response.statusText);
                
                if (!response.ok) {
                    throw new Error(`Backend proxy error: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('üì∫ TV shows data received:', data.results?.length, 'shows');
                
                // Store TV shows for display
                allTVShows = data.results.map(item => ({...item, media_type: 'tv'}));
                
                // Initially show first 20 TV shows
                tvShowsLoaded = 20;
                const initialTVShows = allTVShows.slice(0, tvShowsLoaded);
                await displayResults(initialTVShows, tvDiv);
                
                // Update load more button
                updateLoadMoreButton('tv');
                
            } catch (error) {
                console.error('Error loading popular TV shows:', error);
                tvDiv.innerHTML = '<div class="no-results"><h3>‚ö†Ô∏è Error Loading TV Shows</h3><p>Please try again later.</p></div>';
            }
        }

        async function loadMoreMovies() {
            const newMoviesLoaded = Math.min(moviesLoaded + 12, allMovies.length);
            const moviesDiv = document.getElementById('popularMovies');
            
            // Get the new movies to add
            const newMovies = allMovies.slice(moviesLoaded, newMoviesLoaded);
            
            // Check existing cards to prevent duplicates
            const existingCardIds = Array.from(moviesDiv.querySelectorAll('.media-card')).map(card => card.dataset.tmdbId);
            
            // Append new movies to existing content
            for (const movie of newMovies) {
                const movieId = `movie-${movie.id}`;
                
                // Skip if card already exists
                if (existingCardIds.includes(movieId)) {
                    console.log(`Skipping duplicate movie card: ${movie.title || movie.name}`);
                    continue;
                }
                
                const card = await createMediaCard(movie);
                card.dataset.tmdbId = movieId; // Add identifier for duplicate checking
                moviesDiv.appendChild(card);
            }
            
            moviesLoaded = newMoviesLoaded;
            updateLoadMoreButton('movies');
            
            // Smooth scroll to the new content
            setTimeout(() => {
                const lastCard = moviesDiv.lastElementChild;
                if (lastCard) {
                    lastCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 100);
        }

        async function loadMoreTVShows() {
            const newTVShowsLoaded = Math.min(tvShowsLoaded + 12, allTVShows.length);
            const tvDiv = document.getElementById('popularTVShows');
            
            // Get the new TV shows to add
            const newTVShows = allTVShows.slice(tvShowsLoaded, newTVShowsLoaded);
            
            // Check existing cards to prevent duplicates
            const existingCardIds = Array.from(tvDiv.querySelectorAll('.media-card')).map(card => card.dataset.tmdbId);
            
            // Append new TV shows to existing content
            for (const tvShow of newTVShows) {
                const showId = `tv-${tvShow.id}`;
                
                // Skip if card already exists
                if (existingCardIds.includes(showId)) {
                    console.log(`Skipping duplicate TV show card: ${tvShow.title || tvShow.name}`);
                    continue;
                }
                
                const card = await createMediaCard(tvShow);
                card.dataset.tmdbId = showId; // Add identifier for duplicate checking
                tvDiv.appendChild(card);
            }
            
            tvShowsLoaded = newTVShowsLoaded;
            updateLoadMoreButton('tv');
            
            // Smooth scroll to the new content
            setTimeout(() => {
                const lastCard = tvDiv.lastElementChild;
                if (lastCard) {
                    lastCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 100);
        }

        function updateLoadMoreButton(type) {
            if (type === 'movies') {
                const button = document.getElementById('loadMoreMoviesBtn');
                if (moviesLoaded >= allMovies.length) {
                    button.style.display = 'none';
                } else {
                    button.style.display = 'block';
                    button.textContent = `Load More (${allMovies.length - moviesLoaded} remaining)`;
                }
            } else if (type === 'tv') {
                const button = document.getElementById('loadMoreTVBtn');
                if (tvShowsLoaded >= allTVShows.length) {
                    button.style.display = 'none';
                } else {
                    button.style.display = 'block';
                    button.textContent = `Load More (${allTVShows.length - tvShowsLoaded} remaining)`;
                }
            }
        }

        // Browse all content with pagination
        async function showAllMovies() {
            currentBrowseType = 'movie';
            currentPage = 1;
            await loadBrowseContent();
        }

        async function showAllTVShows() {
            currentBrowseType = 'tv';
            currentPage = 1;
            await loadBrowseContent();
        }

        async function loadBrowseContent() {
            document.getElementById('mainContent').style.display = 'none';
            document.getElementById('searchResultsSection').style.display = 'none';
            document.getElementById('browseSection').style.display = 'block';
            
            const browseTitle = document.getElementById('browseTitle');
            browseTitle.textContent = currentBrowseType === 'movie' ? 'üçø All Movies' : 'üì∫ All TV Shows';
            
            const browseResults = document.getElementById('browseResults');
            browseResults.innerHTML = '<div class="loading"><div class="spinner"></div><p>Loading content...</p></div>';
            
            try {
                const response = await fetch(`${TMDB_BASE_URL}/${currentBrowseType}/popular?api_key=${window.tmdbApiKey}&page=${currentPage}`);
                const data = await response.json();
                
                totalPages = Math.min(data.total_pages, 500); // TMDB limits to 500 pages
                const content = data.results.map(item => ({...item, media_type: currentBrowseType}));
                
                await displayResults(content, browseResults);
                setupPagination();
                
            } catch (error) {
                console.error('Error loading browse content:', error);
                browseResults.innerHTML = '<div class="no-results"><h3>‚ö†Ô∏è Error Loading Content</h3><p>Please try again later.</p></div>';
            }
        }

        function setupPagination() {
            const pagination = document.getElementById('browsePagination');
            pagination.style.display = 'flex';
            
            let paginationHTML = '';
            
            // Previous button
            paginationHTML += `<button class="page-btn" ${currentPage === 1 ? 'disabled' : ''} onclick="changePage(${currentPage - 1})">‚Üê Previous</button>`;
            
            // Page numbers
            const startPage = Math.max(1, currentPage - 2);
            const endPage = Math.min(totalPages, currentPage + 2);
            
            if (startPage > 1) {
                paginationHTML += `<button class="page-btn" onclick="changePage(1)">1</button>`;
                if (startPage > 2) {
                    paginationHTML += `<span class="page-info">...</span>`;
                }
            }
            
            for (let i = startPage; i <= endPage; i++) {
                paginationHTML += `<button class="page-btn ${i === currentPage ? 'active' : ''}" onclick="changePage(${i})">${i}</button>`;
            }
            
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    paginationHTML += `<span class="page-info">...</span>`;
                }
                paginationHTML += `<button class="page-btn" onclick="changePage(${totalPages})">${totalPages}</button>`;
            }
            
            // Next button
            paginationHTML += `<button class="page-btn" ${currentPage === totalPages ? 'disabled' : ''} onclick="changePage(${currentPage + 1})">Next ‚Üí</button>`;
            
            // Page info
            paginationHTML += `<span class="page-info">Page ${currentPage} of ${totalPages}</span>`;
            
            pagination.innerHTML = paginationHTML;
        }

        async function changePage(page) {
            if (page < 1 || page > totalPages || page === currentPage) return;
            
            currentPage = page;
            await loadBrowseContent();
            
            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // Browse all content with pagination
        async function showAllMovies() {
            currentBrowseType = 'movie';
            currentPage = 1;
            await loadBrowseContent();
        }

        async function showAllTVShows() {
            currentBrowseType = 'tv';
            currentPage = 1;
            await loadBrowseContent();
        }

        async function loadBrowseContent() {
            // For now, just show more popular content
            // This can be enhanced later with pagination
            console.log('Loading browse content for:', currentBrowseType);
            
            try {
                let response;
                if (currentBrowseType === 'movie') {
                    response = await fetch(`${TMDB_BASE_URL}/movie/popular?api_key=${window.tmdbApiKey}&page=1`);
                } else {
                    response = await fetch(`${TMDB_BASE_URL}/tv/popular?api_key=${window.tmdbApiKey}&page=1`);
                }
                
                const data = await response.json();
                const content = data.results.map(item => ({...item, media_type: currentBrowseType}));
                
                // Show in search results area
                const searchResults = document.getElementById('searchResults');
                const mainContent = document.getElementById('mainContent');
                
                mainContent.style.display = 'none';
                searchResults.style.display = 'grid';
                
                displayResults(content, searchResults);
                
            } catch (error) {
                console.error('Error loading browse content:', error);
            }
        }

        function backToHome() {
            document.getElementById('searchResults').style.display = 'none';
            document.getElementById('mainContent').style.display = 'block';
        }

        function clearSearch() {
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.value = '';
            }
            document.getElementById('searchResults').style.display = 'none';
            document.getElementById('mainContent').style.display = 'block';
        }

        // Display results
        async function displayResults(results, container) {
            console.log('üìã displayResults called with:', {
                resultsLength: results.length,
                containerElement: !!container,
                containerId: container?.id
            });
            
            if (!container) {
                console.error('‚ùå Container not found for displaying results');
                return;
            }
            
            if (results.length === 0) {
                console.log('üìã No results to display');
                container.innerHTML = '<div class="no-results"><h3>üîç No Results Found</h3><p>Try a different search term.</p></div>';
                return;
            }
            
            console.log('üìã Clearing container and creating cards...');
            container.innerHTML = '';
            
            // Process cards sequentially to maintain order
            for (let i = 0; i < results.length; i++) {
                const item = results[i];
                console.log(`üìã Creating card ${i + 1}/${results.length} for:`, item.title || item.name);
                try {
                    const card = await createMediaCard(item);
                    // Add identifier for duplicate checking
                    const mediaType = item.media_type || currentMediaType;
                    card.dataset.tmdbId = `${mediaType}-${item.id}`;
                    container.appendChild(card);
                    console.log(`‚úÖ Card ${i + 1} added successfully`);
                } catch (error) {
                    console.error(`‚ùå Error creating card ${i + 1}:`, error);
                }
            }
            
            console.log('‚úÖ displayResults completed - all cards should be visible now');
            
            // Check Plex availability after a short delay to ensure DOM is ready
            setTimeout(() => {
                checkCurrentContentAvailability();
            }, 500);
        }

        // Utility function to calculate countdown from date
        function calculateCountdownFromDate(retryAfterISO) {
            const now = new Date();
            const retryDate = new Date(retryAfterISO);
            const diffMs = retryDate.getTime() - now.getTime();
            
            if (diffMs <= 0) {
                return {
                    expired: true,
                    daysLeft: 0,
                    hoursLeft: 0,
                    message: 'Available now!'
                };
            }
            
            const daysLeft = Math.ceil(diffMs / (1000 * 60 * 60 * 24));
            const hoursLeft = Math.ceil(diffMs / (1000 * 60 * 60));
            
            let message;
            if (daysLeft >= 1) {
                const dayText = daysLeft === 1 ? 'day' : 'days';
                message = `Check back in ${daysLeft} ${dayText}`;
            } else if (hoursLeft >= 1) {
                const hourText = hoursLeft === 1 ? 'hour' : 'hours';
                message = `Check back in ${hoursLeft} ${hourText}`;
            } else {
                message = 'Check back soon!';
            }
            
            return {
                expired: false,
                daysLeft,
                hoursLeft,
                message
            };
        }

        // Create media card with bot integration
        async function createMediaCard(item) {
            const card = document.createElement('div');
            card.className = 'media-card';
            
            const title = item.title || item.name;
            const year = item.release_date || item.first_air_date;
            const mediaType = item.media_type || currentMediaType;
            const mediaId = mediaType + '-' + item.id;
            
            const userRequest = userRequests.get(mediaId);
            let buttonText = 'Request ' + (mediaType === 'tv' ? 'Episodes' : 'Movie');
            let buttonClass = 'request-btn';
            let buttonDisabled = false;
            let episodeStatusHTML = '';
            
            // Check global availability first (for all users)
            let globalAvailability = null;
            try {
                if (window.apiClient) {
                    globalAvailability = await window.apiClient.getGlobalAvailability(item.id, mediaType);
                }
            } catch (error) {
                console.log('Global availability check failed:', error.message);
            }
            
            // Handle TV shows with requests
            if (mediaType === 'tv' && userRequest) {
                // Check if the request failed or is not available
                if (userRequest.status === 'not_available' || userRequest.status === 'error') {
                    // Show error status like movies
                    buttonDisabled = true;
                    
                    if (userRequest.status === 'not_available' && userRequest.retryAfter) {
                        // Calculate countdown for user's own request
                        const countdownInfo = calculateCountdownFromDate(userRequest.retryAfter);
                        if (!countdownInfo.expired) {
                            buttonText = `${countdownInfo.message} üìÖ`;
                            episodeStatusHTML = `<div class="episode-status" style="margin-bottom: 10px; padding: 8px; background: rgba(255, 107, 107, 0.1); border-radius: 6px; border: 1px solid rgba(255, 107, 107, 0.3); font-size: 0.8rem; line-height: 1.5; color: #ff6b6b; font-weight: 600;">‚è∞ ${countdownInfo.message} - Try again later</div>`;
                        } else {
                            buttonText = 'Try Again Now! üîÑ';
                            buttonDisabled = false;
                            episodeStatusHTML = `<div class="episode-status" style="margin-bottom: 10px; padding: 8px; background: rgba(40, 167, 69, 0.1); border-radius: 6px; border: 1px solid rgba(40, 167, 69, 0.3); font-size: 0.8rem; line-height: 1.5; color: #28a745; font-weight: 600;">‚úÖ Countdown expired - You can try requesting again!</div>`;
                        }
                    } else {
                        episodeStatusHTML = `<div class="episode-status" style="margin-bottom: 10px; padding: 8px; background: rgba(255, 107, 107, 0.1); border-radius: 6px; border: 1px solid rgba(255, 107, 107, 0.3); font-size: 0.8rem; line-height: 1.5; color: #ff6b6b; font-weight: 600;">${userRequest.status === 'not_available' ? 'üö´ Not Available' : '‚ö†Ô∏è Error'}</div>`;
                        buttonText = userRequest.status === 'not_available' ? 'Not Available üö´' : 'Error ‚ö†Ô∏è';
                    }
                    buttonClass = `request-btn ${userRequest.status}`;
                } else if (userRequest.selectedEpisodes) {
                    // Show episode info for successful requests
                const episodeInfo = formatRequestedEpisodes(userRequest.selectedEpisodes, userRequest.status);
                if (episodeInfo) {
                    episodeStatusHTML = `<div class="episode-status" style="margin-bottom: 10px; padding: 8px; background: rgba(40, 167, 69, 0.1); border-radius: 6px; border: 1px solid rgba(40, 167, 69, 0.3); font-size: 0.8rem; line-height: 1.5;">${episodeInfo}</div>`;
                }
                buttonText = 'Request More Episodes';
                }
            } else if (mediaType === 'movie' && userRequest) {
                buttonDisabled = true;
                switch (userRequest.status) {
                    case 'pending':
                        // Allow pending items to be clicked again (ultra aggressive - 1 minute)
                        const pendingAge = Date.now() - new Date(userRequest.timestamp?.seconds * 1000 || userRequest.lastUpdated || Date.now());
                        if (pendingAge > 1 * 60 * 1000) { // 1 minute old
                            buttonText = 'Request Movie üîÑ';
                            buttonClass = 'request-btn retry-enabled';
                            buttonDisabled = false;
                        } else {
                        buttonText = 'Pending ‚è≥';
                        buttonClass = 'request-btn pending';
                        }
                        break;
                    case 'approved':
                        buttonText = 'Approved ‚úÖ';
                        buttonClass = 'request-btn approved';
                        break;
                    case 'not_available':
                        if (userRequest.retryAfter) {
                            const countdownInfo = calculateCountdownFromDate(userRequest.retryAfter);
                            if (!countdownInfo.expired) {
                                buttonText = `${countdownInfo.message} üìÖ`;
                                buttonClass = 'request-btn not_available';
                            } else {
                                buttonText = 'Try Again Now! üîÑ';
                                buttonClass = 'request-btn';
                                buttonDisabled = false;
                            }
                        } else {
                            buttonText = 'Not Available üö´';
                            buttonClass = 'request-btn not_available';
                        }
                        break;
                    case 'no_storage':
                        buttonText = 'No Storage üíæ';
                        buttonClass = 'request-btn no_storage';
                        break;
                    case 'already_exists':
                        buttonText = 'Already Available üì¶';
                        buttonClass = 'request-btn already_exists';
                        break;
                    case 'added_to_client':
                        buttonText = 'Added to Queue üì•';
                        buttonClass = 'request-btn added_to_queue';
                        break;
                    case 'downloading':
                        buttonText = 'Downloading ‚¨áÔ∏è';
                        buttonClass = 'request-btn downloading';
                        break;
                    case 'added':  // Legacy status, map to new one
                        buttonText = 'Added to Queue üì•';
                        buttonClass = 'request-btn added_to_queue';
                        break;
                    case 'error':
                        // Allow error items to be retried after 30 seconds
                        const errorAge = Date.now() - new Date(userRequest.timestamp?.seconds * 1000 || userRequest.lastUpdated || Date.now());
                        if (errorAge > 30 * 1000) { // 30 seconds old
                            buttonText = 'Request Movie üîÑ';
                            buttonClass = 'request-btn retry-enabled';
                            buttonDisabled = false;
                        } else {
                        buttonText = 'Error ‚ö†Ô∏è';
                        buttonClass = 'request-btn error';
                        }
                        break;
                }
            }
            
            // Handle global availability status (overrides user request for display)
            if (globalAvailability) {
                if (globalAvailability.globalStatus === 'available') {
                    if (mediaType === 'movie') {
                        buttonDisabled = true;
                        buttonText = 'Available ‚úÖ';
                        buttonClass = 'request-btn approved';
                        const source = globalAvailability.plexAvailable ? 'in your Plex library' : 'from previous request';
                        episodeStatusHTML = `<div class="episode-status" style="margin-bottom: 10px; padding: 8px; background: rgba(40, 167, 69, 0.1); border-radius: 6px; border: 1px solid rgba(40, 167, 69, 0.3); font-size: 0.8rem; line-height: 1.5; color: #28a745; font-weight: 600;">üì¶ Already available ${source}</div>`;
                    } else {
                        buttonDisabled = true;
                        buttonText = 'All Episodes Available ‚úÖ';
                        buttonClass = 'request-btn approved';
                        const source = globalAvailability.plexAvailable ? 'in your Plex library' : 'from previous requests';
                        episodeStatusHTML = `<div class="episode-status" style="margin-bottom: 10px; padding: 8px; background: rgba(40, 167, 69, 0.1); border-radius: 6px; border: 1px solid rgba(40, 167, 69, 0.3); font-size: 0.8rem; line-height: 1.5; color: #28a745; font-weight: 600;">üì¶ All episodes available ${source}</div>`;
                    }
                } else if (globalAvailability.globalStatus === 'partially_available' && mediaType === 'tv') {
                    buttonDisabled = false;
                    buttonText = 'Request Missing Episodes üìÇ';
                    buttonClass = 'request-btn partially_available';
                    
                    const availableCount = globalAvailability.availableEpisodeCount || 0;
                    const seasons = Object.keys(globalAvailability.availableEpisodes || {});
                    const fullSeasons = globalAvailability.fullSeasonsAvailable || [];
                    
                    // Enhanced status display with completeness info
                    let statusText = `üìÇ ${availableCount} episodes available`;
                    if (fullSeasons.length > 0) {
                        statusText += ` (Complete: ${fullSeasons.join(', ')})`;
                    }
                    if (seasons.length > fullSeasons.length) {
                        const partialSeasons = seasons.filter(s => !fullSeasons.includes(s));
                        statusText += ` (Partial: ${partialSeasons.join(', ')})`;
                    }
                    statusText += ' - Click to request missing episodes';
                    
                    episodeStatusHTML = `<div class="episode-status" style="margin-bottom: 10px; padding: 8px; background: rgba(255, 165, 0, 0.1); border-radius: 6px; border: 1px solid rgba(255, 165, 0, 0.3); font-size: 0.8rem; line-height: 1.5; color: #ff8c00; font-weight: 600;">${statusText}</div>`;
                    
                    // Store partial availability data for episode selection
                    card.dataset.partiallyAvailable = 'true';
                    card.dataset.availableEpisodes = JSON.stringify(globalAvailability.availableEpisodes || {});
                    card.dataset.plexEpisodes = JSON.stringify(globalAvailability.plexEpisodes || {});
                    card.dataset.seasonCompleteness = JSON.stringify(globalAvailability.seasonCompleteness || {});
                } else if (globalAvailability.globalStatus === 'not_available' || (globalAvailability.countdownInfo && !globalAvailability.countdownInfo.expired)) {
                    buttonDisabled = true;
                    
                    if (globalAvailability.countdownInfo && !globalAvailability.countdownInfo.expired) {
                        buttonText = `${globalAvailability.countdownInfo.message} üìÖ`;
                        buttonClass = 'request-btn not_available';
                        episodeStatusHTML = `<div class="episode-status" style="margin-bottom: 10px; padding: 8px; background: rgba(255, 107, 107, 0.1); border-radius: 6px; border: 1px solid rgba(255, 107, 107, 0.3); font-size: 0.8rem; line-height: 1.5; color: #ff6b6b; font-weight: 600;">‚è∞ ${globalAvailability.countdownInfo.message} - Content may become available soon</div>`;
                    } else {
                        buttonText = 'Not Available üö´';
                        buttonClass = 'request-btn not_available';
                        episodeStatusHTML = `<div class="episode-status" style="margin-bottom: 10px; padding: 8px; background: rgba(255, 107, 107, 0.1); border-radius: 6px; border: 1px solid rgba(255, 107, 107, 0.3); font-size: 0.8rem; line-height: 1.5; color: #ff6b6b; font-weight: 600;">üö´ Not Available</div>`;
                    }
                }
            }
            
            // Check weekly limit (but not for TV shows that already have requests)
            if (!userRequest && userTier !== 'VIP' && userRequestCount >= weeklyLimit) {
                buttonDisabled = true;
                buttonText = 'Weekly Limit Reached';
            }
            
            // Create safe title for SVG (remove special characters and emojis)
            const safeTitle = title.replace(/[^\x00-\x7F]/g, "").substring(0, 30) || "Media";
            
            let posterPath;
            if (item.poster_path) {
                posterPath = 'https://image.tmdb.org/t/p/w500' + item.poster_path;
            } else {
                // Use a simple fallback instead of SVG to avoid encoding issues
                posterPath = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
                    <svg width="300" height="450" xmlns="http://www.w3.org/2000/svg">
                        <rect width="300" height="450" fill="#1a1a3a"/>
                        <text x="150" y="200" font-family="Arial" font-size="16" fill="white" text-anchor="middle">
                            ${safeTitle}
                        </text>
                        <circle cx="150" cy="300" r="30" fill="#4ecdc4" opacity="0.3"/>
                        <text x="150" y="305" font-family="Arial" font-size="24" fill="#4ecdc4" text-anchor="middle">üé¨</text>
                    </svg>
                `);
            }
            
            // Add data attributes for media identification and partial availability
            card.dataset.mediaId = mediaId;
            
            // Create the card HTML without inline onclick to avoid quote issues
            card.innerHTML = `
                <img src="${posterPath}" alt="${title}" class="media-poster">
                <div class="media-info">
                    <h3 class="media-title">${title}</h3>
                    <div class="media-meta">
                        <span class="media-year">${year ? new Date(year).getFullYear() : 'Unknown'}</span>
                        <span class="media-type-badge">${mediaType === 'tv' ? 'TV' : 'Movie'}</span>
                    </div>
                    <p class="media-overview">${item.overview || 'No description available.'}</p>
                    ${episodeStatusHTML}
                    <button class="${buttonClass}" id="btn-${mediaId}" ${buttonDisabled ? 'disabled' : ''}>
                        ${buttonText}
                    </button>
                </div>
            `;
            
            // Add event listener to the button instead of inline onclick
            const button = card.querySelector(`#btn-${mediaId}`);
            if (button && !buttonDisabled) {
                button.addEventListener('click', function() {
                    requestMedia(item);
                });
            }
            
            return card;
        }

        // OPTIMIZED: Request media with queue system to prevent conflicts
        async function requestMedia(media) {
            if (!currentUser) {
                alert('Please sign in to make requests.');
                return;
            }
            
            if (userTier !== 'VIP' && userRequestCount >= weeklyLimit) {
                alert(`You've reached your weekly limit of ${weeklyLimit} requests. Limit resets on Sunday.`);
                return;
            }
            
            // Add to queue to prevent conflicts
            requestQueue.push(() => processMediaRequest(media));
            
            if (!isProcessingRequest) {
                await processRequestQueue();
            }
        }
        
        async function processRequestQueue() {
            if (isProcessingRequest || requestQueue.length === 0) return;
            
            isProcessingRequest = true;
            
            while (requestQueue.length > 0) {
                const requestFunc = requestQueue.shift();
                try {
                    await requestFunc();
                } catch (error) {
                    console.error('Request processing error:', error);
                }
            }
            
            isProcessingRequest = false;
        }
        
        async function processMediaRequest(media) {
            selectedMedia = media;
            const mediaType = media.media_type || currentMediaType;
            
            if (mediaType === 'tv') {
                await showSeasonSelector(media.id);
            } else {
                selectedEpisodes = {};
                await submitRequest();
            }
        }

        // Submit request via secure backend API
        async function submitRequest() {
            console.log('üì§ Submitting request via backend API');
            if (!currentUser || !selectedMedia) return;
            
            const mediaType = selectedMedia.media_type || currentMediaType;
            const episodeData = {};
            
            for (const [season, episodes] of Object.entries(selectedEpisodes)) {
                episodeData[`S${String(season).padStart(2, '0')}`] = episodes.sort((a, b) => a - b);
            }
            
            const requestData = {
                tmdbId: selectedMedia.id,
                title: selectedMedia.title || selectedMedia.name,
                mediaType: mediaType === 'tv' ? 'tv' : 'movie',
                poster_path: selectedMedia.poster_path,
                userName: currentUser.name,
                userEmail: currentUser.email,
                userId: currentUser.id,
                selectedEpisodes: episodeData
            };
            
            try {
                const response = await window.apiClient.createRequest(requestData);
                console.log('‚úÖ Request submitted via backend API:', response.id);
                
                // Update user request count if not VIP
                if (userTier !== 'VIP') {
                    userRequestCount++;
                }
                
                let summaryText = '';
                if (mediaType === 'tv' && Object.keys(episodeData).length > 0) {
                    for (const [season, episodes] of Object.entries(episodeData)) {
                        const seasonNum = parseInt(season.replace('S', ''));
                        const seasonDetails = tvShowDetails?.seasons?.find(s => s.season_number === seasonNum);
                        const totalEpisodes = seasonDetails ? seasonDetails.episode_count : episodes.length;
                        
                        if (episodes.length === totalEpisodes) {
                            summaryText += `\n  ‚Ä¢ ${season}: All episodes`;
                        } else {
                            summaryText += `\n  ‚Ä¢ ${season}: Episodes ${episodes.join(', ')}`;
                        }
                    }
                }
                
                updateUserInfoDisplay();
                alert(`‚úÖ Request submitted successfully for ${requestData.title}!${summaryText}\n\nYour bot will process this request and update the status automatically.`);
                
                selectedMedia = null;
                selectedEpisodes = {};
                tvShowDetails = null;
                
            } catch (error) {
                console.error('‚ùå Request submission error:', error);
                alert('Error submitting request: ' + error.message);
                throw error;
            }
        }

        // Load user requests from backend API
        async function loadUserRequests() {
            if (!currentUser) return;
            
            try {
                const response = await window.apiClient.getUserRequests(currentUser.id);
                const requests = response.requests || [];
                
                requests.forEach((data) => {
                        const mediaId = data.mediaType + '-' + data.tmdbId;
                        
                        if (data.mediaType === 'tv') {
                            const existingRequest = userRequests.get(mediaId);
                            if (existingRequest && existingRequest.selectedEpisodes) {
                                for (const [season, episodes] of Object.entries(data.selectedEpisodes || {})) {
                                    if (!existingRequest.selectedEpisodes[season]) {
                                        existingRequest.selectedEpisodes[season] = [];
                                    }
                                    existingRequest.selectedEpisodes[season] = [
                                        ...new Set([...existingRequest.selectedEpisodes[season], ...episodes])
                                    ].sort((a, b) => a - b);
                                }
                                if (data.status === 'approved' || existingRequest.status !== 'approved') {
                                    existingRequest.status = data.status;
                                }
                            } else {
                                userRequests.set(mediaId, data);
                            }
                        } else {
                            userRequests.set(mediaId, data);
                    }
                });
                
                console.log('üìã Loaded user requests:', userRequests.size);
                
                // Update UI for all loaded requests to show current status
                // Wait a bit for the DOM to be ready, then update all cards
                setTimeout(() => {
                    for (const [mediaId, request] of userRequests.entries()) {
                        console.log('üîÑ Updating UI for:', mediaId, 'Status:', request.status);
                        updateMediaCardDisplay(mediaId);
                    }
                }, 1000); // 1 second delay to ensure DOM is ready
                
            } catch (error) {
                console.error('Error loading user requests:', error);
            }
        }

        // Listen for real-time request updates via Server-Sent Events
        async function listenForRequestUpdates() {
            if (!currentUser) return;
            
            try {
                // Set up Server-Sent Events connection
                const eventSource = window.apiClient.listenForUpdates(currentUser.id, (data) => {
                            const mediaId = data.mediaType + '-' + data.tmdbId;
                            
                    console.log('üîÑ Request update received:', {
                        mediaId,
                                    status: data.status,
                        type: data.changeType
                                });
                                
                    // Handle TV show data merging
                                if (data.mediaType === 'tv') {
                                    const existingRequest = userRequests.get(mediaId);
                                    if (existingRequest && existingRequest.selectedEpisodes) {
                                        for (const [season, episodes] of Object.entries(data.selectedEpisodes || {})) {
                                            if (!existingRequest.selectedEpisodes[season]) {
                                                existingRequest.selectedEpisodes[season] = [];
                                            }
                                            existingRequest.selectedEpisodes[season] = [
                                                ...new Set([...existingRequest.selectedEpisodes[season], ...episodes])
                                            ].sort((a, b) => a - b);
                                        }
                                        existingRequest.status = data.status;
                                    } else {
                                        userRequests.set(mediaId, data);
                                    }
                                } else {
                                    userRequests.set(mediaId, data);
                                }
                                
                    // Update UI immediately
                                updateMediaCardDisplay(mediaId);
                    });
                
                // Store event source for cleanup
                window.requestUpdateSource = eventSource;
            } catch (error) {
                console.error('Error setting up request listener:', error);
            }
        }

        function updateMediaCardDisplay(mediaId) {
            const button = document.getElementById('btn-' + mediaId);
            if (!button) {
                console.log('‚ö†Ô∏è Button not found for mediaId:', mediaId, '- might not be loaded yet');
                return;
            }
            
            const mediaCard = button.closest('.media-card');
            if (!mediaCard) {
                console.log('‚ö†Ô∏è Media card not found for mediaId:', mediaId);
                return;
            }
            
            const userRequest = userRequests.get(mediaId);
            if (!userRequest) {
                console.log('‚ö†Ô∏è User request not found for mediaId:', mediaId);
                return;
            }
            
            console.log('‚úÖ Updating media card:', mediaId, 'Status:', userRequest.status);
            
            if (userRequest.mediaType === 'tv') {
                let statusDiv = mediaCard.querySelector('.episode-status');
                if (!statusDiv) {
                    statusDiv = document.createElement('div');
                    statusDiv.className = 'episode-status';
                    statusDiv.style.cssText = 'margin-bottom: 10px; padding: 8px; background: rgba(40, 167, 69, 0.1); border-radius: 6px; border: 1px solid rgba(40, 167, 69, 0.3); font-size: 0.8rem; line-height: 1.5;';
                    button.parentNode.insertBefore(statusDiv, button);
                }
                
                // Check if the request failed or is not available
                if (userRequest.status === 'not_available' || userRequest.status === 'error') {
                    // Show error status instead of episode info
                    statusDiv.innerHTML = `<span style="color: #ff6b6b; font-weight: 600;">${userRequest.status === 'not_available' ? 'üö´ Not Available' : '‚ö†Ô∏è Error'}</span>`;
                    statusDiv.style.display = 'block';
                    statusDiv.style.background = 'rgba(255, 107, 107, 0.1)';
                    statusDiv.style.borderColor = 'rgba(255, 107, 107, 0.3)';
                    
                    updateButtonStatus(mediaId, userRequest.status);
                } else {
                    // Normal TV show with episodes
                const episodeInfo = formatRequestedEpisodes(userRequest.selectedEpisodes, userRequest.status);
                if (episodeInfo) {
                    statusDiv.innerHTML = episodeInfo;
                    statusDiv.style.display = 'block';
                        statusDiv.style.background = 'rgba(40, 167, 69, 0.1)';
                        statusDiv.style.borderColor = 'rgba(40, 167, 69, 0.3)';
                }
                
                button.textContent = 'Request More Episodes';
                button.disabled = false;
                }
            } else {
                updateButtonStatus(mediaId, userRequest.status);
            }
        }

        function updateButtonStatus(mediaId, status) {
            const button = document.getElementById('btn-' + mediaId);
            if (!button) return;
            
            button.disabled = true;
            button.className = 'request-btn ' + status;
            
            switch (status) {
                case 'pending':
                    button.textContent = 'Pending ‚è≥';
                    break;
                case 'approved':
                    button.textContent = 'Approved ‚úÖ';
                    break;
                case 'not_available':
                    button.textContent = 'Not Available üö´';
                    break;
                case 'no_storage':
                    button.textContent = 'No Storage üíæ';
                    break;
                case 'already_exists':
                    button.textContent = 'Already Available üì¶';
                    break;
                case 'added_to_client':
                    button.textContent = 'Added to Queue üì•';
                    break;
                case 'downloading':
                    button.textContent = 'Downloading ‚¨áÔ∏è';
                    break;
                case 'error':
                    button.textContent = 'Retry Request ‚ö†Ô∏è';
                    button.disabled = false; // Allow retry on error
                    button.className = 'request-btn error retry-enabled';
                    break;
                case 'added':  // Legacy status, map to new one
                    button.textContent = 'Added to Queue üì•';
                    break;
                case 'searching':
                    button.textContent = 'Searching üîç';
                    break;
                case 'selecting':
                    button.textContent = 'Selecting üéØ';
                    break;
                case 'adding':
                    button.textContent = 'Adding to Client üì§';
                    break;
                case 'added':
                    button.textContent = 'Added to Queue ‚è≥';
                    break;
                case 'completed':
                    button.textContent = 'Added ‚úÖ';
                    break;
                case 'available':
                    button.textContent = 'Already Available üì¶';
                    break;
                default:
                    button.textContent = `${status} üìä`;
                    break;
            }
        }

        function formatRequestedEpisodes(episodeData, status) {
            if (!episodeData || Object.keys(episodeData).length === 0) {
                return null;
            }
            
            const baseStyle = 'display: inline-block; margin: 2px 4px; padding: 2px 6px; color: white; border-radius: 4px; font-size: 0.75rem; font-weight: 500;';
            
            let bgColor = 'background: linear-gradient(45deg, #28a745, #218838);'; // approved
            if (status === 'pending') {
                bgColor = 'background: linear-gradient(45deg, #6c757d, #5a6268);';
            } else if (status === 'preparing') {
                bgColor = 'background: linear-gradient(45deg, #ffc107, #ffca2c);'; // yellow for preparing
            } else if (status === 'added_to_client') {
                bgColor = 'background: linear-gradient(45deg, #ff8c00, #ffa500);'; // orange for queue
            } else if (status === 'downloading') {
                bgColor = 'background: linear-gradient(45deg, #0099ff, #007acc);'; // blue for actually downloading
            } else if (status === 'error' || status === 'not_available') {
                bgColor = 'background: linear-gradient(45deg, #dc3545, #c82333);';
            }
            
            const formattedItems = [];
            
            for (const [season, episodes] of Object.entries(episodeData)) {
                if (!episodes || episodes.length === 0) continue;
                
                const seasonNum = season.replace('S', '');
                const sortedEpisodes = episodes.sort((a, b) => a - b);
                
                const ranges = [];
                let start = sortedEpisodes[0];
                let end = sortedEpisodes[0];
                
                for (let i = 1; i < sortedEpisodes.length; i++) {
                    if (sortedEpisodes[i] === end + 1) {
                        end = sortedEpisodes[i];
                    } else {
                        if (start === end) {
                            ranges.push(`E${String(start).padStart(2, '0')}`);
                        } else {
                            ranges.push(`E${String(start).padStart(2, '0')}-E${String(end).padStart(2, '0')}`);
                        }
                        start = sortedEpisodes[i];
                        end = sortedEpisodes[i];
                    }
                }
                
                if (start === end) {
                    ranges.push(`E${String(start).padStart(2, '0')}`);
                } else {
                    ranges.push(`E${String(start).padStart(2, '0')}-E${String(end).padStart(2, '0')}`);
                }
                
                const seasonText = `${season}: ${ranges.join(', ')}`;
                formattedItems.push(`<span style="${baseStyle} ${bgColor}">${seasonText}</span>`);
            }
            
            const statusIcon = status === 'approved' ? '‚úÖ' : 
                             status === 'pending' ? '‚è≥' : 
                             status === 'preparing' ? 'üîÑ' : 
                             status === 'added_to_client' ? 'üì•' : 
                             status === 'downloading' ? '‚¨áÔ∏è' : 
                             status === 'error' ? '‚ö†Ô∏è' : '';
            
            return `<strong>Requested Episodes ${statusIcon}:</strong> ${formattedItems.join(' ')}`;
        }

        // TV Show Episode Selection Functions
        async function showSeasonSelector(tvId) {
            try {
                console.log('üîç showSeasonSelector called for TV ID:', tvId);
                console.log('üåê Using proxy endpoints for TMDB API calls');
                
                document.getElementById('seasonContent').innerHTML = 
                    '<div style="text-align: center; padding: 20px; color: #a0a0a0;"><div class="spinner"></div><p>Loading episode information...</p></div>';
                
                document.getElementById('seasonModal').style.display = 'block';
                document.getElementById('selectionSummary').style.display = 'none';
                
                selectedEpisodes = {};
                
                const apiUrl = `/api/tmdb/tv/${tvId}`;
                console.log('üîó Fetching TV details from proxy:', apiUrl);
                
                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    throw new Error(`TMDB API request failed: ${response.status} ${response.statusText}`);
                }
                
                tvShowDetails = await response.json();
                console.log('üì∫ TV Show details loaded:', tvShowDetails.name);
                
                // Get existing user requests for this TV show
                const mediaId = 'tv-' + tvId;
                const existingRequest = userRequests.get(mediaId);
                const existingEpisodes = existingRequest?.selectedEpisodes || {};
                
                // Get global availability data (from all users) for partial availability support
                let globalAvailability = null;
                try {
                    globalAvailability = await window.apiClient.getGlobalAvailability(tvId, 'tv');
                    console.log('üåç Global availability data:', globalAvailability);
                } catch (error) {
                    console.warn('Failed to get global availability:', error.message);
                }
                
                const globallyAvailableEpisodes = globalAvailability?.availableEpisodes || {};
                const plexAvailableEpisodes = globalAvailability?.plexEpisodes || {};
                
                let contentHTML = '';
                
                // Enhanced information header for partial availability and global requests
                const hasUserRequests = existingRequest && Object.keys(existingEpisodes).length > 0;
                const hasGlobalAvailability = globalAvailability && Object.keys(globallyAvailableEpisodes).length > 0;
                
                if (hasUserRequests || hasGlobalAvailability) {
                    let headerContent = '';
                    
                    if (hasGlobalAvailability) {
                        const globalEpisodeCount = globalAvailability.availableEpisodeCount || 0;
                        const globalStatus = globalAvailability.globalStatus;
                        
                        if (globalStatus === 'partially_available') {
                            headerContent += `
                                <div style="font-weight: 600; margin-bottom: 8px; color: #ff8c00;">üåç This show is partially available globally!</div>
                                <div style="font-size: 0.9rem; color: #ffb84d; margin-bottom: 12px;">
                                    ${globalEpisodeCount} episodes available from previous requests by all users.
                                </div>
                            `;
                        } else if (globalStatus === 'available') {
                            headerContent += `
                                <div style="font-weight: 600; margin-bottom: 8px; color: #28a745;">üåç This show is fully available!</div>
                                <div style="font-size: 0.9rem; color: #a8d9a8; margin-bottom: 12px;">
                                    All episodes are available from previous requests.
                                </div>
                            `;
                        }
                    }
                    
                    if (hasUserRequests) {
                        headerContent += `
                            <div style="font-weight: 600; margin-bottom: 8px; color: #28a745;">üì∫ You have existing requests for this show!</div>
                        `;
                    }
                    
                    headerContent += `
                        <div style="font-size: 0.9rem; color: #a8d9a8;">
                            ‚Ä¢ <span style="color: #28a745; font-weight: 600;">Green episodes ‚úÖüì¶</span>: Already available globally - cannot be requested<br>
                            ‚Ä¢ <span style="color: #ffc107; font-weight: 600;">Yellow episodes ‚è≥‚¨áÔ∏è</span>: Your pending requests - can be requested again<br>
                            ‚Ä¢ <span style="color: #ffffff; font-weight: 600;">White episodes</span>: Available to request
                        </div>
                    `;
                    
                    contentHTML += `
                        <div style="margin-bottom: 20px; padding: 15px; background: rgba(40, 167, 69, 0.1); border: 1px solid rgba(40, 167, 69, 0.3); border-radius: 10px; color: #ffffff;">
                            ${headerContent}
                        </div>
                    `;
                }
                
                const regularSeasons = tvShowDetails.seasons.filter(season => season.season_number > 0);
                
                for (const season of regularSeasons) {
                    const seasonApiUrl = `/api/tmdb/tv/${tvId}/season/${season.season_number}`;
                    console.log('üîó Fetching season details from proxy:', seasonApiUrl);
                    
                    const seasonResponse = await fetch(seasonApiUrl);
                    
                    if (!seasonResponse.ok) {
                        console.warn(`Failed to load season ${season.season_number}:`, seasonResponse.status);
                        continue;
                    }
                    
                    const seasonDetails = await seasonResponse.json();
                    
                    // Check if this season has existing episodes requested
                    const seasonKey = `S${String(season.season_number).padStart(2, '0')}`;
                    const existingSeasonEpisodes = existingEpisodes[seasonKey] || [];
                    const globallyAvailableSeasonEpisodes = globallyAvailableEpisodes[seasonKey] || [];
                    const plexAvailableSeasonEpisodes = plexAvailableEpisodes[seasonKey] || [];
                    const hasExistingEpisodes = existingSeasonEpisodes.length > 0;
                    const hasGlobalEpisodes = globallyAvailableSeasonEpisodes.length > 0;
                    const hasPlexEpisodes = plexAvailableSeasonEpisodes.length > 0;
                    
                    // Block episodes that are globally available (from any user)
                    const globallyBlockedEpisodes = globallyAvailableSeasonEpisodes;
                    
                    // Only block user's episodes if their request is completed/available - not just pending
                    const shouldBlockUserEpisodes = existingRequest && (
                        existingRequest.status === 'available' || 
                        existingRequest.status === 'completed' || 
                        existingRequest.status === 'approved'
                    );
                    
                    const userBlockedEpisodes = shouldBlockUserEpisodes ? existingSeasonEpisodes : [];
                    
                    // Combine all blocked episodes
                    const allBlockedEpisodes = [...new Set([...globallyBlockedEpisodes, ...userBlockedEpisodes])];
                    const availableEpisodes = seasonDetails.episodes.filter(ep => !allBlockedEpisodes.includes(ep.episode_number));
                    
                    let seasonStatusHTML = '';
                    
                    // Show global availability status
                    if (hasPlexEpisodes) {
                        seasonStatusHTML += `<div style="font-size: 0.8rem; color: #28a745; margin-left: 8px;">
                            üì¶ ${plexAvailableSeasonEpisodes.length} episodes available in Plex
                        </div>`;
                    } else if (hasGlobalEpisodes) {
                        seasonStatusHTML += `<div style="font-size: 0.8rem; color: #28a745; margin-left: 8px;">
                            üåç ${globallyAvailableSeasonEpisodes.length} episodes available globally
                        </div>`;
                    }
                    
                    // Show user's request status
                    if (hasExistingEpisodes) {
                        const statusIcon = existingRequest?.status === 'approved' ? '‚úÖ' : 
                                         existingRequest?.status === 'pending' ? '‚è≥' : 
                                         existingRequest?.status === 'added_to_client' ? 'üì•' :
                                         existingRequest?.status === 'downloading' ? '‚¨áÔ∏è' : 'üìä';
                        const statusText = shouldBlockUserEpisodes ? 'your episodes completed' : 'your episodes pending';
                        const statusColor = shouldBlockUserEpisodes ? '#28a745' : '#ffc107';
                        seasonStatusHTML += `<div style="font-size: 0.8rem; color: ${statusColor}; margin-left: 8px;">
                            ${statusIcon} ${existingSeasonEpisodes.length} ${statusText}
                        </div>`;
                    }
                    
                    contentHTML += `
                        <div style="margin-bottom: 20px; padding: 15px; background: rgba(255, 255, 255, 0.05); border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.1);" data-season="${season.season_number}">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid rgba(255, 255, 255, 0.2); flex-wrap: wrap; gap: 10px;">
                                <div style="font-size: 1.1rem; font-weight: 600; color: #4ecdc4;">
                                    Season ${season.season_number}
                                    <span style="display: inline-block; padding: 2px 6px; background: rgba(255, 255, 255, 0.2); border-radius: 4px; font-size: 0.7rem; margin-left: 8px;">${seasonDetails.episodes.length} episodes</span>
                                    ${seasonStatusHTML}
                                </div>
                                ${availableEpisodes.length > 0 ? `
                                <button onclick="toggleAllEpisodes(${season.season_number})" style="padding: 6px 12px; background: linear-gradient(45deg, #ff6b6b, #ff8e53); border: none; border-radius: 6px; color: #ffffff; font-size: 0.8rem; font-weight: 600; cursor: pointer; -webkit-tap-highlight-color: transparent; touch-action: manipulation;">
                                    Select All Available
                                </button>
                                ` : `
                                <span style="padding: 6px 12px; background: rgba(40, 167, 69, 0.2); border: 1px solid rgba(40, 167, 69, 0.5); border-radius: 6px; color: #28a745; font-size: 0.8rem; font-weight: 600;">
                                    All Episodes Requested
                                </span>
                                `}
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); gap: 8px;" id="episodes-${season.season_number}">
                    `;
                    
                    for (const episode of seasonDetails.episodes) {
                        const episodeTitle = episode.name || `Episode ${episode.episode_number}`;
                        const isUserRequested = existingSeasonEpisodes.includes(episode.episode_number);
                        const isGloballyAvailable = globallyAvailableSeasonEpisodes.includes(episode.episode_number);
                        const isPlexAvailable = plexAvailableSeasonEpisodes.includes(episode.episode_number);
                        const isUserBlocked = userBlockedEpisodes.includes(episode.episode_number);
                        const isGloballyBlocked = globallyBlockedEpisodes.includes(episode.episode_number);
                        
                        if (isPlexAvailable) {
                            // Plex available episode - show as green/disabled (highest priority)
                            contentHTML += `
                                <div data-season="${season.season_number}" data-episode="${episode.episode_number}" style="padding: 8px 6px; background: rgba(40, 167, 69, 0.3); border: 1px solid rgba(40, 167, 69, 0.7); border-radius: 6px; color: #28a745; font-size: 0.8rem; text-align: center; position: relative; opacity: 0.9;">
                                    <div>E${String(episode.episode_number).padStart(2, '0')} üì¶</div>
                                    <div style="font-size: 0.6rem; color: #28a745; margin-top: 4px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${episodeTitle}">In Plex</div>
                                </div>
                            `;
                        } else if (isGloballyAvailable) {
                            // Globally available episode - show as disabled with global indicator
                            const statusIcon = isUserRequested && isUserBlocked ? '‚úÖ' : 'üåç';
                            const statusText = isUserRequested && isUserBlocked ? 'Available' : 'Global';
                            contentHTML += `
                                <div data-season="${season.season_number}" data-episode="${episode.episode_number}" style="padding: 8px 6px; background: rgba(40, 167, 69, 0.2); border: 1px solid rgba(40, 167, 69, 0.5); border-radius: 6px; color: #28a745; font-size: 0.8rem; text-align: center; position: relative; opacity: 0.8;">
                                    <div>E${String(episode.episode_number).padStart(2, '0')} ${statusIcon}</div>
                                    <div style="font-size: 0.6rem; color: #28a745; margin-top: 4px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${episodeTitle}">${statusText}</div>
                                </div>
                            `;
                        } else if (isUserRequested && !isUserBlocked) {
                            // Pending episode - show as orange/yellow (can still request more)
                            const statusIcon = existingRequest?.status === 'pending' ? '‚è≥' : 
                                             existingRequest?.status === 'added_to_client' ? 'üì•' :
                                             existingRequest?.status === 'downloading' ? '‚¨áÔ∏è' : 'üìä';
                            contentHTML += `
                                <div onclick="toggleEpisode(${season.season_number}, ${episode.episode_number})" data-season="${season.season_number}" data-episode="${episode.episode_number}" style="padding: 8px 6px; background: rgba(255, 193, 7, 0.2); border: 1px solid rgba(255, 193, 7, 0.5); border-radius: 6px; color: #ffc107; font-size: 0.8rem; cursor: pointer; transition: all 0.2s ease; text-align: center; position: relative; -webkit-tap-highlight-color: transparent; touch-action: manipulation;">
                                    <div>E${String(episode.episode_number).padStart(2, '0')} ${statusIcon}</div>
                                    <div style="font-size: 0.6rem; color: #ffc107; margin-top: 4px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${episodeTitle}">Pending</div>
                                </div>
                            `;
                        } else {
                            // Available episode - can be selected
                        contentHTML += `
                            <div onclick="toggleEpisode(${season.season_number}, ${episode.episode_number})" data-season="${season.season_number}" data-episode="${episode.episode_number}" style="padding: 8px 6px; background: rgba(255, 255, 255, 0.08); border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 6px; color: #ffffff; font-size: 0.8rem; cursor: pointer; transition: all 0.2s ease; text-align: center; position: relative; -webkit-tap-highlight-color: transparent; touch-action: manipulation;">
                                <div>E${String(episode.episode_number).padStart(2, '0')}</div>
                                <div style="font-size: 0.7rem; color: #a0a0a0; margin-top: 4px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${episodeTitle}">${episodeTitle}</div>
                            </div>
                        `;
                        }
                    }
                    
                    contentHTML += `</div></div>`;
                }
                
                document.getElementById('seasonContent').innerHTML = contentHTML;
                
            } catch (error) {
                console.error('‚ùå Error loading season information:', error);
                console.error('‚ùå Error details:', {
                    message: error.message,
                    tvId: tvId,
                    stack: error.stack
                });
                
                let errorMessage = 'Unable to load episode information. ';
                if (error.message.includes('TMDB API request failed')) {
                    errorMessage = `TMDB API error: ${error.message}. Please try again.`;
                } else {
                    errorMessage += `Error: ${error.message}`;
                }
                
                document.getElementById('seasonContent').innerHTML = 
                    `<div style="text-align: center; padding: 40px; color: #ff6b6b;">
                        <h3>‚ö†Ô∏è Error Loading Episodes</h3>
                        <p>${errorMessage}</p>
                        <button onclick="retryEpisodeLoading(${tvId})" style="margin-top: 15px; padding: 8px 16px; background: #4ecdc4; border: none; border-radius: 6px; color: white; cursor: pointer;">
                            Retry Loading Episodes
                        </button>
                    </div>`;
            }
        }

        // Retry episode loading for a specific TV show without refreshing the whole page
        async function retryEpisodeLoading(tvId) {
            console.log('üîÑ Retrying episode loading for TV ID:', tvId);
            
            // Wait a moment for any pending loads
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Retry the season selector using proxy endpoints (no API key needed)
            await showSeasonSelector(tvId);
        }

        function toggleEpisode(seasonNumber, episodeNumber) {
            // Check if this episode is blocked (completed/available or globally available)
            const mediaId = 'tv-' + selectedMedia.id;
            const existingRequest = userRequests.get(mediaId);
            const existingEpisodes = existingRequest?.selectedEpisodes || {};
            const seasonKey = `S${String(seasonNumber).padStart(2, '0')}`;
            const existingSeasonEpisodes = existingEpisodes[seasonKey] || [];
            
            // Check if episode is globally available (from the current card data)
            const mediaCard = document.querySelector(`[data-media-id="${mediaId}"]`);
            let globallyAvailableEpisodes = {};
            
            if (mediaCard && mediaCard.dataset.availableEpisodes) {
                try {
                    globallyAvailableEpisodes = JSON.parse(mediaCard.dataset.availableEpisodes);
                } catch (e) {
                    console.warn('Failed to parse globally available episodes data');
                }
            }
            
            const globallyAvailableSeasonEpisodes = globallyAvailableEpisodes[seasonKey] || [];
            const isGloballyAvailable = globallyAvailableSeasonEpisodes.includes(episodeNumber);
            
            // Get Plex-specific episode data
            let plexAvailableEpisodes = {};
            if (mediaCard && mediaCard.dataset.plexEpisodes) {
                try {
                    plexAvailableEpisodes = JSON.parse(mediaCard.dataset.plexEpisodes);
                } catch (e) {
                    console.warn('Failed to parse Plex available episodes data');
                }
            }
            const plexAvailableSeasonEpisodes = plexAvailableEpisodes[seasonKey] || [];
            const isPlexAvailable = plexAvailableSeasonEpisodes.includes(episodeNumber);
            
            // Only block user episodes if their request is completed/available
            const shouldBlockUserEpisodes = existingRequest && (
                existingRequest.status === 'available' || 
                existingRequest.status === 'completed' || 
                existingRequest.status === 'approved'
            );
            
            const isUserBlocked = shouldBlockUserEpisodes && existingSeasonEpisodes.includes(episodeNumber);
            
            if (isPlexAvailable) {
                // Episode is available in Plex - can't request again
                alert(`Episode ${episodeNumber} of Season ${seasonNumber} is already available in your Plex library and cannot be requested.`);
                return;
            }
            
            if (isGloballyAvailable) {
                // Episode is globally available - can't request again
                alert(`Episode ${episodeNumber} of Season ${seasonNumber} is already available globally and cannot be requested again.`);
                return;
            }
            
            if (isUserBlocked) {
                // Episode is completed/available by user - can't request again
                alert(`Episode ${episodeNumber} of Season ${seasonNumber} is already available from your previous request and cannot be requested again.`);
                return;
            }
            
            if (!selectedEpisodes[seasonNumber]) {
                selectedEpisodes[seasonNumber] = [];
            }
            
            const index = selectedEpisodes[seasonNumber].indexOf(episodeNumber);
            const episodeBtn = document.querySelector(
                `[data-season="${seasonNumber}"][data-episode="${episodeNumber}"]`
            );
            
            if (index > -1) {
                selectedEpisodes[seasonNumber].splice(index, 1);
                episodeBtn.style.background = 'rgba(255, 255, 255, 0.08)';
                episodeBtn.style.borderColor = 'rgba(255, 255, 255, 0.15)';
                episodeBtn.style.fontWeight = 'normal';
                
                if (selectedEpisodes[seasonNumber].length === 0) {
                    delete selectedEpisodes[seasonNumber];
                }
            } else {
                selectedEpisodes[seasonNumber].push(episodeNumber);
                episodeBtn.style.background = 'linear-gradient(45deg, #4ecdc4, #45b7d1)';
                episodeBtn.style.borderColor = '#4ecdc4';
                episodeBtn.style.fontWeight = '600';
            }
            
            updateSelectAllButton(seasonNumber);
            updateSelectionSummary();
        }

        function toggleAllEpisodes(seasonNumber) {
            // Get existing episodes for this season
            const mediaId = 'tv-' + selectedMedia.id;
            const existingRequest = userRequests.get(mediaId);
            const existingEpisodes = existingRequest?.selectedEpisodes || {};
            const seasonKey = `S${String(seasonNumber).padStart(2, '0')}`;
            const existingSeasonEpisodes = existingEpisodes[seasonKey] || [];
            
            // Only block if the request is completed/available
            const shouldBlockEpisodes = existingRequest && (
                existingRequest.status === 'available' || 
                existingRequest.status === 'completed' || 
                existingRequest.status === 'approved'
            );
            
            const blockedEpisodes = shouldBlockEpisodes ? existingSeasonEpisodes : [];
            
            // Only get clickable episodes (not blocked)
            const episodeBtns = Array.from(document.querySelectorAll(`[data-season="${seasonNumber}"][data-episode]`))
                .filter(btn => btn.onclick && !blockedEpisodes.includes(parseInt(btn.dataset.episode)));
            
            const selectAllBtn = document.querySelector(`[data-season="${seasonNumber}"] button`);
            
            const allAvailableSelected = selectedEpisodes[seasonNumber] && 
                               selectedEpisodes[seasonNumber].length === episodeBtns.length;
            
            if (allAvailableSelected) {
                delete selectedEpisodes[seasonNumber];
                episodeBtns.forEach(btn => {
                    btn.style.background = 'rgba(255, 255, 255, 0.08)';
                    btn.style.borderColor = 'rgba(255, 255, 255, 0.15)';
                    btn.style.fontWeight = 'normal';
                });
                selectAllBtn.textContent = 'Select All Available';
                selectAllBtn.style.background = 'linear-gradient(45deg, #ff6b6b, #ff8e53)';
            } else {
                selectedEpisodes[seasonNumber] = [];
                episodeBtns.forEach(btn => {
                    const episodeNum = parseInt(btn.dataset.episode);
                    selectedEpisodes[seasonNumber].push(episodeNum);
                    btn.style.background = 'linear-gradient(45deg, #4ecdc4, #45b7d1)';
                    btn.style.borderColor = '#4ecdc4';
                    btn.style.fontWeight = '600';
                });
                selectAllBtn.textContent = 'Deselect All';
                selectAllBtn.style.background = 'linear-gradient(45deg, #4ecdc4, #45b7d1)';
            }
            
            updateSelectionSummary();
        }

        function updateSelectAllButton(seasonNumber) {
            // Get existing episodes for this season
            const mediaId = 'tv-' + selectedMedia.id;
            const existingRequest = userRequests.get(mediaId);
            const existingEpisodes = existingRequest?.selectedEpisodes || {};
            const seasonKey = `S${String(seasonNumber).padStart(2, '0')}`;
            const existingSeasonEpisodes = existingEpisodes[seasonKey] || [];
            
            // Only block if the request is completed/available
            const shouldBlockEpisodes = existingRequest && (
                existingRequest.status === 'available' || 
                existingRequest.status === 'completed' || 
                existingRequest.status === 'approved'
            );
            
            const blockedEpisodes = shouldBlockEpisodes ? existingSeasonEpisodes : [];
            
            // Only count clickable episodes (not blocked)
            const episodeBtns = Array.from(document.querySelectorAll(`[data-season="${seasonNumber}"][data-episode]`))
                .filter(btn => btn.onclick && !blockedEpisodes.includes(parseInt(btn.dataset.episode)));
            
            const selectAllBtn = document.querySelector(`[data-season="${seasonNumber}"] button`);
            
            if (!selectAllBtn) return;
            
            const allAvailableSelected = selectedEpisodes[seasonNumber] && 
                               selectedEpisodes[seasonNumber].length === episodeBtns.length;
            
            if (allAvailableSelected) {
                selectAllBtn.textContent = 'Deselect All';
                selectAllBtn.style.background = 'linear-gradient(45deg, #4ecdc4, #45b7d1)';
            } else {
                selectAllBtn.textContent = 'Select All Available';
                selectAllBtn.style.background = 'linear-gradient(45deg, #ff6b6b, #ff8e53)';
            }
        }

        function updateSelectionSummary() {
            const summarySection = document.getElementById('selectionSummary');
            const summaryText = document.getElementById('summaryText');
            
            if (Object.keys(selectedEpisodes).length === 0) {
                summarySection.style.display = 'none';
                return;
            }
            
            let summary = '';
            const seasons = Object.keys(selectedEpisodes).sort((a, b) => parseInt(a) - parseInt(b));
            
            for (const season of seasons) {
                const episodes = selectedEpisodes[season].sort((a, b) => a - b);
                const seasonDetails = tvShowDetails.seasons.find(s => s.season_number === parseInt(season));
                const totalEpisodes = seasonDetails ? seasonDetails.episode_count : episodes.length;
                
                if (episodes.length === totalEpisodes) {
                    summary += `<div>‚Ä¢ <strong>Season ${season}</strong>: All episodes (${episodes.length})</div>`;
                } else {
                    const ranges = [];
                    let start = episodes[0];
                    let end = episodes[0];
                    
                    for (let i = 1; i < episodes.length; i++) {
                        if (episodes[i] === end + 1) {
                            end = episodes[i];
                        } else {
                            ranges.push(start === end ? `E${start}` : `E${start}-E${end}`);
                            start = episodes[i];
                            end = episodes[i];
                        }
                    }
                    ranges.push(start === end ? `E${start}` : `E${start}-E${end}`);
                    
                    summary += `<div>‚Ä¢ <strong>Season ${season}</strong>: ${ranges.join(', ')} (${episodes.length} episodes)</div>`;
                }
            }
            
            summaryText.innerHTML = summary;
            summarySection.style.display = 'block';
        }

        function closeSeasonModal() {
            document.getElementById('seasonModal').style.display = 'none';
            selectedEpisodes = {};
            selectedMedia = null;
            tvShowDetails = null;
        }

        async function confirmRequest() {
            if (Object.keys(selectedEpisodes).length === 0) {
                // Check if there are any episodes available to request
                const mediaId = 'tv-' + selectedMedia.id;
                const existingRequest = userRequests.get(mediaId);
                const existingEpisodes = existingRequest?.selectedEpisodes || {};
                
                let hasAvailableEpisodes = false;
                if (tvShowDetails && tvShowDetails.seasons) {
                    for (const season of tvShowDetails.seasons.filter(s => s.season_number > 0)) {
                        const seasonKey = `S${String(season.season_number).padStart(2, '0')}`;
                        const existingSeasonEpisodes = existingEpisodes[seasonKey] || [];
                        if (existingSeasonEpisodes.length < season.episode_count) {
                            hasAvailableEpisodes = true;
                            break;
                        }
                    }
                }
                
                if (hasAvailableEpisodes) {
                    alert('Please select at least one episode to request.');
                } else {
                    alert('All episodes for this TV show have already been requested.');
                }
                return;
            }
            
            console.log('‚úÖ Confirming TV show request with episodes:', selectedEpisodes);
            document.getElementById('seasonModal').style.display = 'none';
            
            try {
                await submitRequest();
            } catch (error) {
                console.error('‚ö†Ô∏è Error in confirmRequest:', error);
                alert('Error submitting request: ' + error.message);
            }
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üìã DOM loaded, initializing...');
            addTouchSupport();
            
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'light') {
                document.body.classList.add('light-mode');
                document.getElementById('themeIcon').textContent = '‚òÄÔ∏è';
                document.getElementById('themeText').textContent = 'Dark';
            }
            
            if (!checkSavedSession()) {
                // Popular content will be loaded after config is fetched
                console.log('üì± Not signed in - popular content will load after config');
            }
            
            // Add search input event listener for Enter key
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        console.log('üîç Search triggered by Enter key');
                        searchMedia();
                    }
                });
                console.log('‚úÖ Search input Enter listener added');
            } else {
                console.error('‚ùå Search input element not found');
            }
            
            // Add search button click event listener
            const searchBtn = document.getElementById('searchBtn');
            if (searchBtn) {
                searchBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log('üîç Search button clicked via event listener');
                    searchMedia();
                });
                console.log('‚úÖ Search button click listener added');
            } else {
                console.error('‚ùå Search button element not found');
            }
            
            // Add season modal event listener
            const seasonModal = document.getElementById('seasonModal');
            if (seasonModal) {
                seasonModal.addEventListener('click', function(e) {
                    if (e.target === this) {
                        closeSeasonModal();
                    }
                });
                console.log('‚úÖ Season modal click listener added');
            } else {
                console.error('‚ùå Season modal element not found');
            }

            // Add email input event listener
            const emailInput = document.getElementById('emailInput');
            if (emailInput) {
                emailInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        handleEmailSignIn();
                    }
                });
                console.log('‚úÖ Email input Enter listener added');
            }
            
            console.log('‚úÖ All event listeners added successfully');
        });

        // ============= PLEX AVAILABILITY CHECKING =============
        
        async function checkPlexAvailability(mediaList, forceRefresh = false) {
            try {
                console.log('üîç Checking Plex availability for', mediaList.length, 'items', forceRefresh ? '(FORCE REFRESH)' : '(using cache)');
                
                const response = await fetch('http://localhost:3000/check-plex', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        mediaList,
                        forceRefresh 
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                console.log('üì¶ Plex availability results:', data);
                
                // Store results in localStorage for immediate access
                try {
                    const cacheKey = 'plexAvailabilityCache';
                    let cache = JSON.parse(localStorage.getItem(cacheKey) || '{}');
                    
                    // Merge new results with existing cache
                    Object.assign(cache, data.results || {});
                    
                    localStorage.setItem(cacheKey, JSON.stringify(cache));
                    console.log('üíæ Updated local Plex availability cache');
                } catch (cacheError) {
                    console.warn('Failed to update local cache:', cacheError);
                }
                
                return data.results || {};
                
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to check Plex availability:', error);
                
                // Fallback to localStorage cache if API fails
                try {
                    const cache = JSON.parse(localStorage.getItem('plexAvailabilityCache') || '{}');
                    if (Object.keys(cache).length > 0) {
                        console.log('üì¶ Using local cache fallback');
                        return cache;
                    }
                } catch (fallbackError) {
                    console.warn('Cache fallback failed:', fallbackError);
                }
                
                return {};
            }
        }
        
        function addPlexAvailabilityBadges(plexResults) {
            Object.entries(plexResults).forEach(([mediaId, result]) => {
                const button = document.getElementById('btn-' + mediaId);
                if (!button) return;
                
                const mediaCard = button.closest('.media-card');
                if (!mediaCard) return;
                
                // Remove existing badges
                const existingBadge = mediaCard.querySelector('.plex-availability-badge');
                if (existingBadge) {
                    existingBadge.remove();
                }
                
                if (result.available) {
                    // Add "Available in Plex" badge
                    const badge = document.createElement('div');
                    badge.className = 'plex-availability-badge';
                    badge.innerHTML = 'üì¶ Available in Plex';
                    badge.style.cssText = `
                        position: absolute;
                        top: 8px;
                        right: 8px;
                        background: rgba(40, 167, 69, 0.9);
                        color: white;
                        padding: 4px 8px;
                        border-radius: 12px;
                        font-size: 0.7rem;
                        font-weight: 600;
                        z-index: 10;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                    `;
                    
                    // Make media card container relative if it isn't already
                    if (getComputedStyle(mediaCard).position === 'static') {
                        mediaCard.style.position = 'relative';
                    }
                    
                    mediaCard.appendChild(badge);
                    
                    // Update button to show already available
                    button.textContent = 'Already Available üì¶';
                    button.disabled = true;
                    button.className = 'request-btn already_exists';
                }
            });
        }
        
        // Check Plex availability when content is loaded
        function checkCurrentContentAvailability(forceRefresh = false) {
            const mediaCards = document.querySelectorAll('.media-card');
            const mediaList = [];
            
            mediaCards.forEach(card => {
                const button = card.querySelector('.request-btn');
                if (button && button.id.startsWith('btn-')) {
                    const mediaId = button.id.replace('btn-', '');
                    const [mediaType, tmdbId] = mediaId.split('-');
                    
                    const titleElement = card.querySelector('.media-title');
                    const yearElement = card.querySelector('.media-year');
                    
                    if (titleElement && tmdbId) {
                        mediaList.push({
                            mediaType: mediaType,
                            tmdbId: parseInt(tmdbId),
                            title: titleElement.textContent.trim(),
                            year: yearElement ? parseInt(yearElement.textContent) : null
                        });
                    }
                }
            });
            
            if (mediaList.length > 0) {
                // First, load any cached results immediately for instant display
                if (!forceRefresh) {
                    loadCachedPlexResults(mediaList);
                }
                
                // Then check for updates via API
                checkPlexAvailability(mediaList, forceRefresh).then(plexResults => {
                    addPlexAvailabilityBadges(plexResults);
                });
            }
        }
        
        function loadCachedPlexResults(mediaList) {
            try {
                const cache = JSON.parse(localStorage.getItem('plexAvailabilityCache') || '{}');
                if (Object.keys(cache).length === 0) return;
                
                console.log('üì¶ Loading cached Plex results for instant display');
                
                // Filter cache to only include items currently displayed
                const currentMediaIds = new Set(mediaList.map(media => `${media.mediaType}-${media.tmdbId}`));
                const relevantCache = {};
                
                Object.entries(cache).forEach(([mediaId, result]) => {
                    if (currentMediaIds.has(mediaId)) {
                        relevantCache[mediaId] = result;
                    }
                });
                
                if (Object.keys(relevantCache).length > 0) {
                    addPlexAvailabilityBadges(relevantCache);
                    console.log(`üì¶ Applied ${Object.keys(relevantCache).length} cached Plex statuses`);
                }
                
            } catch (error) {
                console.warn('Failed to load cached Plex results:', error);
            }
        }
        
        console.log('üé¨ Fixed Plex Portal loaded successfully!');
        
        // Add refresh Plex availability button function
        window.refreshPlexAvailability = function() {
            console.log('üîÑ Force refreshing Plex availability...');
            // Clear localStorage cache
            localStorage.removeItem('plexAvailabilityCache');
            // Force refresh current content
            checkCurrentContentAvailability(true);
        };
        
        // Debug functions - you can call these in the browser console
        window.testSearch = function() {
            console.log('üß™ Testing search function');
            document.getElementById('searchInput').value = 'batman';
            searchMedia();
        };
        
        window.testMediaType = function(type) {
            console.log('üß™ Testing media type change to:', type);
            changeMediaType(type);
        };
        
        window.debugState = function() {
            console.log('üêõ Current state:', {
                currentMediaType: currentMediaType,
                currentUser: currentUser,
                searchInput: document.getElementById('searchInput')?.value,
                mainContentVisible: document.getElementById('mainContent')?.style.display !== 'none',
                searchResultsVisible: document.getElementById('searchResults')?.style.display !== 'none'
            });
        };
        
        window.debugSearchResults = function() {
            const searchResults = document.getElementById('searchResults');
            const mainContent = document.getElementById('mainContent');
            const body = document.body;
            
            console.log('üîç SEARCH RESULTS DEBUG:', {
                element: searchResults,
                exists: !!searchResults,
                display: searchResults?.style.display,
                computedDisplay: searchResults ? window.getComputedStyle(searchResults).display : 'none',
                visibility: searchResults ? window.getComputedStyle(searchResults).visibility : 'none',
                position: searchResults ? window.getComputedStyle(searchResults).position : 'none',
                bounds: searchResults ? searchResults.getBoundingClientRect() : null,
                childCount: searchResults ? searchResults.children.length : 0,
                innerHTML: searchResults ? searchResults.innerHTML.substring(0, 200) + '...' : 'none'
            });
            
            console.log('üîç MAIN CONTENT DEBUG:', {
                element: mainContent,
                exists: !!mainContent,
                display: mainContent?.style.display,
                computedDisplay: mainContent ? window.getComputedStyle(mainContent).display : 'none'
            });
            
            // Create a completely new test element that bypasses all existing CSS
            const testElement = document.createElement('div');
            testElement.id = 'emergency-test';
            testElement.innerHTML = `
                <h1>EMERGENCY TEST - CAN YOU SEE THIS?</h1>
                <p>If you can see this, the JavaScript is working!</p>
                <p>Search results children: ${searchResults ? searchResults.children.length : 'none'}</p>
            `;
            testElement.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                background: yellow !important;
                color: black !important;
                z-index: 999999 !important;
                padding: 50px !important;
                font-size: 24px !important;
                border: 10px solid red !important;
                box-sizing: border-box !important;
            `;
            
            // Remove any existing test
            const existing = document.getElementById('emergency-test');
            if (existing) existing.remove();
            
            // Add to body
            body.appendChild(testElement);
            console.log('üîç Added emergency test element to body');
            
            // Also try to make search results super visible
            if (searchResults) {
                searchResults.style.cssText = `
                    display: block !important;
                    position: fixed !important;
                    top: 50px !important;
                    left: 50px !important;
                    width: 90% !important;
                    height: 400px !important;
                    background: red !important;
                    border: 5px solid yellow !important;
                    z-index: 9999 !important;
                    overflow: auto !important;
                `;
                console.log('üîç Applied emergency styles to search results');
            }
        };
        
        window.removeEmergencyTest = function() {
            const existing = document.getElementById('emergency-test');
            if (existing) {
                existing.remove();
                console.log('üîç Removed emergency test element');
            }
        };
        
        console.log('üß™ Debug functions available: testSearch(), testMediaType(type), debugState(), debugSearchResults()');
    </script>
</body>
</html>
</html>
