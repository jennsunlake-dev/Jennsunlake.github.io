<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plex Request Portal</title>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js';
        import { getFirestore, collection, addDoc, doc, getDoc, setDoc, updateDoc, onSnapshot, getDocs } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js';

        const firebaseConfig = {
            apiKey: "AIzaSyDjPme91T08wE2EU8zcY257PWhWVLff_2Y",
            authDomain: "plex-ab76b.firebaseapp.com",
            projectId: "plex-ab76b",
            storageBucket: "plex-ab76b.firebasestorage.app",
            messagingSenderId: "90028665456",
            appId: "1:90028665456:web:cb92b90922c42654bda2b5",
            measurementId: "G-37FFRXK89P"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        window.firebaseApp = app;
        window.db = db;
        window.collection = collection;
        window.addDoc = addDoc;
        window.doc = doc;
        window.getDoc = getDoc;
        window.setDoc = setDoc;
        window.updateDoc = updateDoc;
        window.onSnapshot = onSnapshot;
        window.getDocs = getDocs;
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3a 50%, #2d1b4e 100%);
            color: #ffffff;
            min-height: 100vh;
            transition: all 0.3s ease;
        }

        body.light-mode {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 50%, #dee2e6 100%);
            color: #212529;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px 0;
            position: relative;
        }

        .theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            padding: 8px 16px;
            color: #ffffff;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .light-mode .theme-toggle {
            background: rgba(0, 0, 0, 0.1);
            border-color: rgba(0, 0, 0, 0.2);
            color: #212529;
        }

        .light-mode .theme-toggle:hover {
            background: rgba(0, 0, 0, 0.2);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .search-section {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 40px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .light-mode .search-section {
            background: rgba(255, 255, 255, 0.7);
            border-color: rgba(0, 0, 0, 0.1);
        }

        .search-container {
            position: relative;
            margin-bottom: 20px;
        }

        .search-input {
            width: 100%;
            padding: 18px 60px 18px 20px;
            font-size: 1.1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            color: #ffffff;
            outline: none;
            transition: all 0.3s ease;
        }

        .light-mode .search-input {
            background: rgba(255, 255, 255, 0.9);
            border-color: rgba(0, 0, 0, 0.2);
            color: #212529;
        }

        .search-input:focus {
            border-color: #4ecdc4;
            background: rgba(255, 255, 255, 0.15);
        }

        .light-mode .search-input:focus {
            background: rgba(255, 255, 255, 1);
        }

        .search-input::placeholder {
            color: #a0a0a0;
        }

        .search-btn {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border: none;
            padding: 12px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1.2rem;
        }

        .media-type-selector {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .media-type-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            font-weight: 500;
        }

        .light-mode .media-type-btn {
            background: rgba(0, 0, 0, 0.05);
            border-color: rgba(0, 0, 0, 0.2);
            color: #212529;
        }

        .media-type-btn.active {
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
            border-color: #ff6b6b;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .media-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            overflow: hidden;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .light-mode .media-card {
            background: rgba(255, 255, 255, 0.8);
            border-color: rgba(0, 0, 0, 0.1);
        }

        .media-card:hover {
            transform: translateY(-5px);
            border-color: #4ecdc4;
        }

        .media-poster {
            width: 100%;
            height: 350px;
            object-fit: cover;
        }

        .media-info {
            padding: 15px;
        }

        .media-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: #ffffff;
        }

        .light-mode .media-title {
            color: #212529;
        }

        .media-year {
            color: #4ecdc4;
            font-weight: 500;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .media-overview {
            color: #a0a0a0;
            font-size: 0.8rem;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .light-mode .media-overview {
            color: #6c757d;
        }

        .request-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border: none;
            border-radius: 8px;
            color: #ffffff;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .request-btn:hover {
            background: linear-gradient(45deg, #45b7d1, #4ecdc4);
        }

        .request-btn:disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }

        .request-btn.pending {
            background: linear-gradient(45deg, #808080, #696969);
        }

        .request-btn.approved {
            background: linear-gradient(45deg, #28a745, #218838);
        }

        .request-btn.not_available {
            background: linear-gradient(45deg, #ff0000, #dc143c);
        }

        .request-btn.no_storage {
            background: linear-gradient(45deg, #ffa500, #ff8c00);
        }

        .request-btn.already_exists {
            background: linear-gradient(45deg, #00ffff, #1e90ff);
        }

        .request-btn.downloading {
            background: linear-gradient(45deg, #0099ff, #007acc);
        }

        .request-btn.error {
            background: linear-gradient(45deg, #ff6b6b, #ff4444);
        }

        /* New styles for episode status display */
        .episode-status {
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(40, 167, 69, 0.1);
            border-radius: 6px;
            border: 1px solid rgba(40, 167, 69, 0.3);
            font-size: 0.85rem;
            line-height: 1.5;
        }

        .episode-status-item {
            display: inline-block;
            margin: 2px 4px;
            padding: 2px 6px;
            background: linear-gradient(45deg, #28a745, #218838);
            color: white;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .episode-status-pending {
            background: linear-gradient(45deg, #6c757d, #5a6268);
        }

        .episode-status-downloading {
            background: linear-gradient(45deg, #0099ff, #007acc);
        }

        .episode-status-error {
            background: linear-gradient(45deg, #dc3545, #c82333);
        }

        .user-info {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .light-mode .user-info {
            background: rgba(255, 255, 255, 0.7);
            border-color: rgba(0, 0, 0, 0.1);
        }

        .user-info.signed-out {
            justify-content: center;
            text-align: center;
        }

        .sign-in-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .sign-in-prompt {
            color: #a0a0a0;
            font-size: 1.1rem;
        }

        .light-mode .sign-in-prompt {
            color: #6c757d;
        }

        .test-signin-btn {
            background: #ffffff;
            color: #333;
            border: 1px solid #dadce0;
            padding: 12px 24px;
            border-radius: 4px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            font-size: 14px;
        }

        .test-signin-btn:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            background: #fafafa;
        }

        .user-profile {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .user-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid #4ecdc4;
        }

        .user-details-signed-in {
            display: flex;
            flex-direction: column;
        }

        .user-name {
            font-weight: 600;
            color: #ffffff;
            font-size: 1.1rem;
        }

        .light-mode .user-name {
            color: #212529;
        }

        .user-email {
            color: #a0a0a0;
            font-size: 0.9rem;
        }

        .light-mode .user-email {
            color: #6c757d;
        }

        .sign-out-btn {
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .light-mode .sign-out-btn {
            background: rgba(0, 0, 0, 0.05);
            color: #212529;
            border-color: rgba(0, 0, 0, 0.2);
        }

        .requests-remaining {
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
            padding: 10px 20px;
            border-radius: 15px;
            font-weight: 600;
        }

        .content-locked {
            filter: blur(5px);
            pointer-events: none;
            opacity: 0.5;
        }

        .no-results {
            text-align: center;
            padding: 50px;
            color: #a0a0a0;
        }

        .no-results h3 {
            font-size: 1.5rem;
            margin-bottom: 10px;
            color: #ffffff;
        }

        .light-mode .no-results h3 {
            color: #212529;
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: #a0a0a0;
        }

        .light-mode .loading {
            color: #6c757d;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left: 4px solid #4ecdc4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a1a3a 0%, #2d1b4e 100%);
            padding: 30px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 700px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            transition: all 0.3s ease;
        }

        .light-mode .modal-content {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-color: rgba(0, 0, 0, 0.2);
        }

        .modal h3 {
            margin-bottom: 20px;
            color: #ffffff;
            font-size: 1.5rem;
        }

        .light-mode .modal h3 {
            color: #212529;
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
            margin-top: 30px;
        }

        .modal-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
        }

        .modal-btn.primary {
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            color: #ffffff;
        }

        .modal-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
        }

        .light-mode .modal-btn.secondary {
            background: rgba(0, 0, 0, 0.05);
            color: #212529;
        }

        .user-tier {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-left: 10px;
        }

        .tier-STANDARD {
            background: linear-gradient(45deg, #6c757d, #495057);
            color: #ffffff;
        }

        .tier-PRO {
            background: linear-gradient(45deg, #9b59b6, #8e44ad);
            color: #ffffff;
        }

        .tier-VIP {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #212529;
        }

        .vip-badge {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #212529;
            padding: 4px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: bold;
            margin-left: 8px;
        }

        .email-input {
            width: 100%;
            max-width: 300px;
            padding: 12px 16px;
            font-size: 1rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            margin-bottom: 15px;
            outline: none;
            transition: all 0.3s ease;
        }

        .email-input:focus {
            border-color: #4ecdc4;
            background: rgba(255, 255, 255, 0.15);
        }

        .email-input::placeholder {
            color: #a0a0a0;
        }

        .light-mode .email-input {
            background: rgba(255, 255, 255, 0.9);
            border-color: rgba(0, 0, 0, 0.3);
            color: #212529;
        }

        .light-mode .email-input:focus {
            background: rgba(255, 255, 255, 1);
        }

        /* New styles for episode selection */
        .season-section {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .light-mode .season-section {
            background: rgba(0, 0, 0, 0.02);
            border-color: rgba(0, 0, 0, 0.1);
        }

        .season-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .light-mode .season-header {
            border-bottom-color: rgba(0, 0, 0, 0.2);
        }

        .season-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #4ecdc4;
        }

        .select-all-btn {
            padding: 6px 12px;
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
            border: none;
            border-radius: 6px;
            color: #ffffff;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .select-all-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 107, 107, 0.3);
        }

        .select-all-btn.selected {
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
        }

        .episodes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 8px;
        }

        .episode-btn {
            padding: 8px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            color: #ffffff;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            position: relative;
        }

        .light-mode .episode-btn {
            background: rgba(0, 0, 0, 0.03);
            border-color: rgba(0, 0, 0, 0.15);
            color: #212529;
        }

        .episode-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
        }

        .episode-btn.selected {
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border-color: #4ecdc4;
            font-weight: 600;
        }

        .episode-title {
            font-size: 0.75rem;
            color: #a0a0a0;
            margin-top: 4px;
            display: block;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .loading-episodes {
            text-align: center;
            padding: 20px;
            color: #a0a0a0;
        }

        .summary-section {
            margin-top: 20px;
            padding: 15px;
            background: rgba(78, 205, 196, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(78, 205, 196, 0.3);
        }

        .summary-title {
            font-size: 1rem;
            font-weight: 600;
            color: #4ecdc4;
            margin-bottom: 10px;
        }

        .summary-content {
            font-size: 0.9rem;
            line-height: 1.6;
            color: #ffffff;
        }

        .light-mode .summary-content {
            color: #212529;
        }

        .episode-count {
            display: inline-block;
            padding: 2px 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            font-size: 0.75rem;
            margin-left: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <button class="theme-toggle" onclick="toggleTheme()">
                <span id="themeIcon">üåô</span>
                <span id="themeText">Light Mode</span>
            </button>
            <h1>üé¨ Plex Request Portal</h1>
        </div>

        <div class="user-info signed-out" id="userInfo">
            <div class="sign-in-section">
                <p class="sign-in-prompt">Sign in to request movies and TV shows</p>
                
                <!-- Google Sign-In Button -->
                <div id="g_id_onload"
                     data-client_id="90028665456-2hbgv8ou7hjr4pjh2pq2v5t21oflfdc8.apps.googleusercontent.com"
                     data-context="signin"
                     data-ux_mode="popup"
                     data-callback="handleCredentialResponse"
                     data-auto_prompt="false">
                </div>
                <div class="g_id_signin"
                     data-type="standard"
                     data-shape="pill"
                     data-theme="filled_blue"
                     data-text="signin_with"
                     data-size="large"
                     data-logo_alignment="left">
                </div>
                
                <!-- Fallback Email Sign-In -->
                <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.2);">
                    <p style="font-size: 0.9rem; color: #a0a0a0; margin-bottom: 15px;">Or sign in with email:</p>
                    <input type="email" class="email-input" id="emailInput" placeholder="Enter your authorized email">
                    <button class="test-signin-btn" onclick="handleEmailSignIn()">
                        <svg width="16" height="16" viewBox="0 0 24 24" style="margin-right: 8px;">
                            <path fill="currentColor" d="M20,8L12,13L4,8V6L12,11L20,6M20,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6C2,4.89 21.1,4 20,4Z"/>
                        </svg>
                        Email Sign In
                    </button>
                    <p style="font-size: 0.75rem; color: #666; margin-top: 8px;">
                        Only authorized emails can access this system
                    </p>
                </div>
            </div>
        </div>

        <div class="search-section content-locked">
            <div class="search-container">
                <input type="text" class="search-input" id="searchInput" placeholder="Search for movies and TV shows...">
                <button class="search-btn" onclick="searchMedia()">üîç</button>
            </div>
            
            <div class="media-type-selector">
                <button class="media-type-btn active" data-type="multi">All</button>
                <button class="media-type-btn" data-type="movie">Movies</button>
                <button class="media-type-btn" data-type="tv">TV Shows</button>
            </div>
        </div>

        <div id="results" class="content-locked">
            <div class="no-results">
                <h3>üé¨ Welcome to Plex Request Portal</h3>
                <p>Search for your favorite movies and TV shows above to get started!</p>
            </div>
        </div>
    </div>

    <!-- Enhanced Episode Selection Modal -->
    <div id="seasonModal" class="modal">
        <div class="modal-content">
            <h3>Select Episodes</h3>
            <p>Choose which episodes you'd like to request:</p>
            <div id="seasonContent" class="season-content">
                <div class="loading-episodes">
                    <div class="spinner"></div>
                    <p>Loading episode information...</p>
                </div>
            </div>
            <div id="selectionSummary" class="summary-section" style="display: none;">
                <div class="summary-title">Selection Summary</div>
                <div class="summary-content" id="summaryText"></div>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn secondary" onclick="closeSeasonModal()">Cancel</button>
                <button class="modal-btn primary" onclick="confirmRequest()">Request Selected</button>
            </div>
        </div>
    </div>

    <script>
        const TMDB_API_KEY = 'df968e81859a06cdd6e642da1684ecf9';
        const TMDB_BASE_URL = 'https://api.themoviedb.org/3';
        const APP_ID = '1403586588985921587';
        
        let currentMediaType = 'multi';
        let selectedMedia = null;
        let selectedEpisodes = {}; // Format: { seasonNumber: [episode1, episode2, ...] }
        let tvShowDetails = null;
        let currentUser = null;
        let userRequestCount = 5;
        let userRequests = new Map();
        let userTier = 'STANDARD';
        let weeklyLimit = 5;

        const USER_TIERS = {
            'STANDARD': { name: 'Standard', requests: 5, color: 'tier-STANDARD' },
            'PRO': { name: 'Pro', requests: 20, color: 'tier-PRO' },
            'VIP': { name: 'VIP', requests: -1, color: 'tier-VIP' }
        };

        // Check for saved session on page load
        function checkSavedSession() {
            const savedUser = localStorage.getItem('plexUser');
            if (savedUser) {
                try {
                    currentUser = JSON.parse(savedUser);
                    console.log('üîÑ Restored user session:', currentUser.email);
                    updateUIForSignedInUser();
                    return true;
                } catch (error) {
                    console.error('Error restoring session:', error);
                    localStorage.removeItem('plexUser');
                }
            }
            return false;
        }

        // Save user session
        function saveUserSession(user) {
            localStorage.setItem('plexUser', JSON.stringify(user));
        }

        // Google Sign-In callback
        function handleCredentialResponse(response) {
            console.log('Google Sign-In response received');
            
            try {
                const responsePayload = decodeJwtResponse(response.credential);
                console.log('Decoded user info:', responsePayload);
                
                const tempUser = {
                    id: responsePayload.sub,
                    name: responsePayload.name,
                    email: responsePayload.email.toLowerCase(),
                    picture: responsePayload.picture,
                    provider: 'google'
                };
                
                checkUserAuthorization(tempUser);
                
            } catch (error) {
                console.error('Error handling Google sign-in:', error);
                alert('Google Sign-In failed. Please try again.');
            }
        }
        
        function decodeJwtResponse(token) {
            const base64Url = token.split('.')[1];
            const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
            const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
            }).join(''));
            return JSON.parse(jsonPayload);
        }

        // Email-based sign in with whitelist check
        async function handleEmailSignIn() {
            const email = document.getElementById('emailInput').value.trim().toLowerCase();
            
            if (!email) {
                alert('Please enter an email address');
                return;
            }

            if (!email.includes('@')) {
                alert('Please enter a valid email address');
                return;
            }

            const tempUser = {
                id: 'email_' + email.replace(/[.@]/g, '_'),
                name: email.split('@')[0],
                email: email,
                picture: 'https://via.placeholder.com/50/4ecdc4/ffffff?text=' + email.charAt(0).toUpperCase(),
                provider: 'email'
            };

            await checkUserAuthorization(tempUser);
        }

        // Check if user is authorized (from ANY Discord channel)
        async function checkUserAuthorization(tempUser) {
            // Show loading state
            const signInElements = document.querySelectorAll('.test-signin-btn, .g_id_signin');
            signInElements.forEach(el => {
                if (el.classList.contains('test-signin-btn')) {
                    el.innerHTML = 'Checking authorization...';
                    el.disabled = true;
                }
            });

            try {
                // Check if email is authorized by looking for user document created by Discord bot
                const userDocId = tempUser.email.replace(/[.@]/g, '_');
                const userDocRef = window.doc(window.db, `artifacts/${APP_ID}/public/data/users`, userDocId);
                const userDoc = await window.getDoc(userDocRef);
                
                // Check if user exists
                if (!userDoc.exists()) {
                    showAuthorizationError('Your email is not in the authorized users list.\n\nTo get access:\n1. Contact an admin to add your email to any Discord channel (Whitelist, PRO, or VIP)\n2. Wait for authorization to be processed\n3. Try signing in again');
                    return;
                }
                
                const userData = userDoc.data();
                console.log('Found user data:', userData);
                
                // More lenient check - if they have ANY tier OR were created by Discord bot, allow access
                if (!userData.tier && !userData.placeholder && !userData.createdBy) {
                    showAuthorizationError('Your email exists but is not properly authorized.\n\nPlease contact an administrator to add your email to a Discord channel.');
                    return;
                }

                // User is authorized! Create session with email-based ID
                currentUser = {
                    ...tempUser,
                    id: userDocId, // Use the email-based ID consistently
                    authorized: true,
                    authorizedAt: new Date().toISOString()
                };

                console.log('‚úÖ User authorized:', currentUser);
                saveUserSession(currentUser);
                updateUIForSignedInUser();

            } catch (error) {
                console.error('Error checking authorization:', error);
                showAuthorizationError('Error checking authorization. Please try again.');
            }
        }

        // Show authorization error and reset UI
        function showAuthorizationError(message) {
            alert('‚ùå Access Denied\n\n' + message);
            
            // Reset UI
            const emailSignInBtn = document.querySelector('.test-signin-btn');
            if (emailSignInBtn) {
                emailSignInBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" style="margin-right: 8px;"><path fill="currentColor" d="M20,8L12,13L4,8V6L12,11L20,6M20,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6C2,4.89 21.1,4 20,4Z"/></svg>Email Sign In';
                emailSignInBtn.disabled = false;
            }
            
            document.getElementById('emailInput').value = '';
        }
        
        async function updateUIForSignedInUser() {
            const userInfo = document.getElementById('userInfo');
            userInfo.className = 'user-info';
            
            userInfo.innerHTML = 
                '<div class="user-profile">' +
                    '<img src="' + currentUser.picture + '" alt="' + currentUser.name + '" class="user-avatar">' +
                    '<div class="user-details-signed-in">' +
                        '<div class="user-name">' + currentUser.name + '</div>' +
                        '<div class="user-email">' + currentUser.email + '</div>' +
                    '</div>' +
                '</div>' +
                '<div style="display: flex; align-items: center; gap: 20px;">' +
                    '<div class="requests-remaining">' +
                        'Loading...' +
                    '</div>' +
                    '<button class="sign-out-btn" onclick="signOut()">Sign Out</button>' +
                '</div>';
            
            document.querySelectorAll('.content-locked').forEach(el => el.classList.remove('content-locked'));
            
            await loadUserData();
            loadUserRequests();
            listenForRequestUpdates();
            loadPopularContent();
        }
        
        async function loadUserData() {
            try {
                if (!window.db || !currentUser) return;
                
                // currentUser.id should already be the email-based ID
                const userDocRef = window.doc(window.db, `artifacts/${APP_ID}/public/data/users`, currentUser.id);
                const userDoc = await window.getDoc(userDocRef);
                
                if (userDoc.exists()) {
                    const userData = userDoc.data();
                    userTier = userData.tier || 'STANDARD';
                    userRequestCount = userData.requestCount || 0;
                    weeklyLimit = userData.weeklyLimit || USER_TIERS[userTier].requests;
                } else {
                    // Create new user document
                    userTier = 'STANDARD';
                    weeklyLimit = USER_TIERS[userTier].requests;
                    userRequestCount = 0;
                    
                    await window.setDoc(userDocRef, {
                        email: currentUser.email,
                        name: currentUser.name,
                        tier: userTier,
                        requestCount: 0,
                        weeklyLimit: weeklyLimit,
                        lastResetDate: new Date(),
                        isVIP: userTier === 'VIP'
                    });
                }
                
                updateUserInfoDisplay();
                setupUserDataListener();
                
            } catch (error) {
                console.error('Error loading user data:', error);
                userTier = 'STANDARD';
                weeklyLimit = 5;
                userRequestCount = 0;
                updateUserInfoDisplay();
            }
        }
        
        function setupUserDataListener() {
            if (!window.db || !currentUser) return;
            
            try {
                const userDocId = currentUser.email.replace(/[.@]/g, '_');
                const userDocRef = window.doc(window.db, `artifacts/${APP_ID}/public/data/users`, userDocId);
                
                window.onSnapshot(userDocRef, (doc) => {
                    if (doc.exists()) {
                        const userData = doc.data();
                        const oldTier = userTier;
                        
                        userTier = userData.tier || 'STANDARD';
                        userRequestCount = userData.requestCount || 0;
                        weeklyLimit = userData.weeklyLimit || USER_TIERS[userTier].requests;
                        
                        updateUserInfoDisplay();
                        
                        if (oldTier !== userTier) {
                            showTierUpgradeNotification(oldTier, userTier);
                        }
                        
                        console.log(`üîÑ User data updated: ${userTier} tier, ${userRequestCount}/${weeklyLimit} requests`);
                    }
                }, (error) => {
                    console.error('Error listening to user data:', error);
                });
                
            } catch (error) {
                console.error('Error setting up user data listener:', error);
            }
        }
        
        function showTierUpgradeNotification(oldTier, newTier) {
            const tierConfig = USER_TIERS[newTier];
            const message = newTier === 'VIP' ? 
                'üéâ Congratulations! You\'ve been upgraded to VIP status with unlimited requests! üëë' :
                `üéâ Your account has been upgraded to ${tierConfig.name} tier with ${tierConfig.requests} weekly requests!`;
            
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(45deg, #4ecdc4, #45b7d1);
                color: white;
                padding: 15px 20px;
                border-radius: 10px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                z-index: 10000;
                max-width: 400px;
                font-weight: 600;
                animation: slideIn 0.3s ease-out;
            `;
            
            if (!document.getElementById('notification-styles')) {
                const style = document.createElement('style');
                style.id = 'notification-styles';
                style.textContent = `
                    @keyframes slideIn {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    @keyframes slideOut {
                        from { transform: translateX(0); opacity: 1; }
                        to { transform: translateX(100%); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }
            
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease-in';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 5000);
        }
        
        function updateUserInfoDisplay() {
            const tierConfig = USER_TIERS[userTier];
            const remainingRequests = weeklyLimit === -1 ? '‚àû' : Math.max(0, weeklyLimit - userRequestCount);
            
            const userInfo = document.getElementById('userInfo');
            userInfo.innerHTML = 
                '<div class="user-profile">' +
                    '<img src="' + currentUser.picture + '" alt="' + currentUser.name + '" class="user-avatar">' +
                    '<div class="user-details-signed-in">' +
                        '<div class="user-name">' + currentUser.name + 
                            '<span class="user-tier ' + tierConfig.color + '">' + tierConfig.name + '</span>' +
                            (userTier === 'VIP' ? '<span class="vip-badge">üëë</span>' : '') +
                        '</div>' +
                        '<div class="user-email">' + currentUser.email + '</div>' +
                    '</div>' +
                '</div>' +
                '<div style="display: flex; align-items: center; gap: 20px;">' +
                    '<div class="requests-remaining">' +
                        '<span id="requestsLeft">' + remainingRequests + '</span> requests remaining' +
                    '</div>' +
                    '<button class="sign-out-btn" onclick="signOut()">Sign Out</button>' +
                '</div>';
        }
        
        function signOut() {
            localStorage.removeItem('plexUser');
            currentUser = null;
            location.reload();
        }

        function toggleTheme() {
            document.body.classList.toggle('light-mode');
            const isLight = document.body.classList.contains('light-mode');
            
            document.getElementById('themeIcon').textContent = isLight ? '‚òÄÔ∏è' : 'üåô';
            document.getElementById('themeText').textContent = isLight ? 'Dark Mode' : 'Light Mode';
            
            localStorage.setItem('theme', isLight ? 'light' : 'dark');
        }

        // Enhanced episode selection functions
        async function showSeasonSelector(tvId) {
            try {
                // Show loading state
                document.getElementById('seasonContent').innerHTML = 
                    '<div class="loading-episodes">' +
                        '<div class="spinner"></div>' +
                        '<p>Loading episode information...</p>' +
                    '</div>';
                
                document.getElementById('seasonModal').style.display = 'block';
                document.getElementById('selectionSummary').style.display = 'none';
                
                // Reset selections
                selectedEpisodes = {};
                
                // Fetch TV show details including seasons
                const response = await fetch(TMDB_BASE_URL + '/tv/' + tvId + '?api_key=' + TMDB_API_KEY);
                tvShowDetails = await response.json();
                
                // Build episode selection UI
                let contentHTML = '';
                
                // Filter out season 0 (specials)
                const regularSeasons = tvShowDetails.seasons.filter(season => season.season_number > 0);
                
                for (const season of regularSeasons) {
                    // Fetch detailed episode information for each season
                    const seasonResponse = await fetch(
                        TMDB_BASE_URL + '/tv/' + tvId + '/season/' + season.season_number + '?api_key=' + TMDB_API_KEY
                    );
                    const seasonDetails = await seasonResponse.json();
                    
                    contentHTML += `
                        <div class="season-section" data-season="${season.season_number}">
                            <div class="season-header">
                                <div class="season-title">
                                    Season ${season.season_number}
                                    <span class="episode-count">${seasonDetails.episodes.length} episodes</span>
                                </div>
                                <button class="select-all-btn" onclick="toggleAllEpisodes(${season.season_number})">
                                    Select All
                                </button>
                            </div>
                            <div class="episodes-grid" id="episodes-${season.season_number}">
                    `;
                    
                    // Add episode buttons
                    for (const episode of seasonDetails.episodes) {
                        const episodeTitle = episode.name || `Episode ${episode.episode_number}`;
                        contentHTML += `
                            <div class="episode-btn" 
                                 onclick="toggleEpisode(${season.season_number}, ${episode.episode_number})"
                                 data-season="${season.season_number}"
                                 data-episode="${episode.episode_number}">
                                <div>E${String(episode.episode_number).padStart(2, '0')}</div>
                                <div class="episode-title" title="${episodeTitle}">${episodeTitle}</div>
                            </div>
                        `;
                    }
                    
                    contentHTML += `
                            </div>
                        </div>
                    `;
                }
                
                document.getElementById('seasonContent').innerHTML = contentHTML;
                
            } catch (error) {
                console.error('Error loading season information:', error);
                document.getElementById('seasonContent').innerHTML = 
                    '<div class="no-results">' +
                        '<h3>‚ùå Error Loading Episodes</h3>' +
                        '<p>Unable to load episode information. Please try again.</p>' +
                    '</div>';
            }
        }
        
        function toggleEpisode(seasonNumber, episodeNumber) {
            if (!selectedEpisodes[seasonNumber]) {
                selectedEpisodes[seasonNumber] = [];
            }
            
            const index = selectedEpisodes[seasonNumber].indexOf(episodeNumber);
            const episodeBtn = document.querySelector(
                `.episode-btn[data-season="${seasonNumber}"][data-episode="${episodeNumber}"]`
            );
            
            if (index > -1) {
                // Remove episode
                selectedEpisodes[seasonNumber].splice(index, 1);
                episodeBtn.classList.remove('selected');
                
                // Clean up empty season
                if (selectedEpisodes[seasonNumber].length === 0) {
                    delete selectedEpisodes[seasonNumber];
                }
            } else {
                // Add episode
                selectedEpisodes[seasonNumber].push(episodeNumber);
                episodeBtn.classList.add('selected');
            }
            
            // Update "Select All" button state
            updateSelectAllButton(seasonNumber);
            
            // Update summary
            updateSelectionSummary();
        }
        
        function toggleAllEpisodes(seasonNumber) {
            const episodeBtns = document.querySelectorAll(
                `.episode-btn[data-season="${seasonNumber}"]`
            );
            const selectAllBtn = document.querySelector(
                `.season-section[data-season="${seasonNumber}"] .select-all-btn`
            );
            
            // Check if all episodes are already selected
            const allSelected = selectedEpisodes[seasonNumber] && 
                               selectedEpisodes[seasonNumber].length === episodeBtns.length;
            
            if (allSelected) {
                // Deselect all
                delete selectedEpisodes[seasonNumber];
                episodeBtns.forEach(btn => btn.classList.remove('selected'));
                selectAllBtn.classList.remove('selected');
                selectAllBtn.textContent = 'Select All';
            } else {
                // Select all
                selectedEpisodes[seasonNumber] = [];
                episodeBtns.forEach(btn => {
                    const episodeNum = parseInt(btn.dataset.episode);
                    selectedEpisodes[seasonNumber].push(episodeNum);
                    btn.classList.add('selected');
                });
                selectAllBtn.classList.add('selected');
                selectAllBtn.textContent = 'Deselect All';
            }
            
            updateSelectionSummary();
        }
        
        function updateSelectAllButton(seasonNumber) {
            const episodeBtns = document.querySelectorAll(
                `.episode-btn[data-season="${seasonNumber}"]`
            );
            const selectAllBtn = document.querySelector(
                `.season-section[data-season="${seasonNumber}"] .select-all-btn`
            );
            
            if (!selectAllBtn) return;
            
            const allSelected = selectedEpisodes[seasonNumber] && 
                               selectedEpisodes[seasonNumber].length === episodeBtns.length;
            
            if (allSelected) {
                selectAllBtn.classList.add('selected');
                selectAllBtn.textContent = 'Deselect All';
            } else {
                selectAllBtn.classList.remove('selected');
                selectAllBtn.textContent = 'Select All';
            }
        }
        
        function updateSelectionSummary() {
            const summarySection = document.getElementById('selectionSummary');
            const summaryText = document.getElementById('summaryText');
            
            if (Object.keys(selectedEpisodes).length === 0) {
                summarySection.style.display = 'none';
                return;
            }
            
            let summary = '';
            const seasons = Object.keys(selectedEpisodes).sort((a, b) => parseInt(a) - parseInt(b));
            
            for (const season of seasons) {
                const episodes = selectedEpisodes[season].sort((a, b) => a - b);
                const seasonDetails = tvShowDetails.seasons.find(s => s.season_number === parseInt(season));
                const totalEpisodes = seasonDetails ? seasonDetails.episode_count : episodes.length;
                
                if (episodes.length === totalEpisodes) {
                    summary += `<div>‚Ä¢ <strong>Season ${season}</strong>: All episodes (${episodes.length})</div>`;
                } else {
                    // Group consecutive episodes
                    const ranges = [];
                    let start = episodes[0];
                    let end = episodes[0];
                    
                    for (let i = 1; i < episodes.length; i++) {
                        if (episodes[i] === end + 1) {
                            end = episodes[i];
                        } else {
                            ranges.push(start === end ? `E${start}` : `E${start}-E${end}`);
                            start = episodes[i];
                            end = episodes[i];
                        }
                    }
                    ranges.push(start === end ? `E${start}` : `E${start}-E${end}`);
                    
                    summary += `<div>‚Ä¢ <strong>Season ${season}</strong>: ${ranges.join(', ')} (${episodes.length} episodes)</div>`;
                }
            }
            
            summaryText.innerHTML = summary;
            summarySection.style.display = 'block';
        }
        
        function closeSeasonModal() {
            document.getElementById('seasonModal').style.display = 'none';
            selectedEpisodes = {};
            selectedMedia = null;
            tvShowDetails = null;
        }
        
        async function confirmRequest() {
            if (Object.keys(selectedEpisodes).length === 0) {
                alert('Please select at least one episode.');
                return;
            }
            
            console.log('‚úÖ Confirming TV show request with episodes:', selectedEpisodes);
            
            // Close modal first
            document.getElementById('seasonModal').style.display = 'none';
            
            // Submit the request
            try {
                await submitRequest();
            } catch (error) {
                console.error('‚ùå Error in confirmRequest:', error);
                alert('Error submitting request: ' + error.message);
            }
        }

        async function submitRequest() {
            console.log('üì§ submitRequest called');
            if (!currentUser) {
                console.error('‚ùå No current user');
                return;
            }
            
            if (!selectedMedia) {
                console.error('‚ùå No selected media');
                return;
            }
            
            const mediaType = selectedMedia.media_type || currentMediaType;
            const mediaId = mediaType + '-' + selectedMedia.id;
            
            // Format episode data for submission
            const episodeData = {};
            for (const [season, episodes] of Object.entries(selectedEpisodes)) {
                episodeData[`S${String(season).padStart(2, '0')}`] = episodes.sort((a, b) => a - b);
            }
            
            const requestData = {
                tmdbId: selectedMedia.id,
                title: selectedMedia.title || selectedMedia.name,
                mediaType: mediaType === 'tv' ? 'tv' : 'movie',
                poster_path: selectedMedia.poster_path,
                userName: currentUser.name,
                userEmail: currentUser.email,
                userId: currentUser.id,
                selectedEpisodes: episodeData, // New field with detailed episode info
                timestamp: new Date(),
                status: 'pending',
                statusText: 'Pending Review'
            };
            
            console.log('üìã Request data prepared:', {
                title: requestData.title,
                type: requestData.mediaType,
                userId: requestData.userId,
                userEmail: requestData.userEmail,
                episodes: episodeData,
                timestamp: requestData.timestamp
            });
            
            try {
                if (!window.db) {
                    throw new Error('Database not initialized');
                }
                
                const requestsRef = window.collection(window.db, `artifacts/${APP_ID}/public/data/requests`);
                console.log('üìù Submitting to Firestore...');
                const docRef = await window.addDoc(requestsRef, requestData);
                console.log('‚úÖ Request submitted successfully with ID:', docRef.id);
                
                // Update user request count (unless VIP)
                if (userTier !== 'VIP') {
                    userRequestCount++;
                    const userDocRef = window.doc(window.db, `artifacts/${APP_ID}/public/data/users`, currentUser.id);
                    await window.updateDoc(userDocRef, { requestCount: userRequestCount });
                    console.log('üìä Updated user request count to:', userRequestCount);
                }
                
                // Build summary for alert
                let summaryText = '';
                for (const [season, episodes] of Object.entries(episodeData)) {
                    const seasonNum = parseInt(season.replace('S', ''));
                    const seasonDetails = tvShowDetails?.seasons?.find(s => s.season_number === seasonNum);
                    const totalEpisodes = seasonDetails ? seasonDetails.episode_count : episodes.length;
                    
                    if (episodes.length === totalEpisodes) {
                        summaryText += `\n  ‚Ä¢ ${season}: All episodes`;
                    } else {
                        summaryText += `\n  ‚Ä¢ ${season}: Episodes ${episodes.join(', ')}`;
                    }
                }
                
                updateUserInfoDisplay();
                
                alert(`Request submitted successfully for ${requestData.title}!${summaryText}\n\nYou'll see status updates here.`);
                
                // Clear selection
                selectedMedia = null;
                selectedEpisodes = {};
                tvShowDetails = null;
                
            } catch (error) {
                console.error('‚ùå Request submission error:', error);
                alert('Error submitting request: ' + error.message);
                throw error;
            }
        }

        async function requestMedia(media) {
            if (!currentUser) {
                alert('Please sign in to make requests.');
                return;
            }
            
            // Check if user has reached their limit (unless VIP)
            if (userTier !== 'VIP' && userRequestCount >= weeklyLimit) {
                alert(`You've reached your weekly limit of ${weeklyLimit} requests. Limit resets on Sunday.`);
                return;
            }
            
            selectedMedia = media;
            const mediaType = media.media_type || currentMediaType;
            
            if (mediaType === 'tv') {
                await showSeasonSelector(media.id);
            } else {
                selectedEpisodes = {};
                await submitRequest();
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'light') {
                document.body.classList.add('light-mode');
                document.getElementById('themeIcon').textContent = '‚òÄÔ∏è';
                document.getElementById('themeText').textContent = 'Dark Mode';
            }
            
            // Check for saved session first
            if (!checkSavedSession()) {
                loadPopularContent();
            }
            
            document.querySelectorAll('.media-type-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.media-type-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentMediaType = this.dataset.type;
                    loadPopularContent();
                });
            });
            
            document.getElementById('searchInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    searchMedia();
                }
            });
            
            document.getElementById('seasonModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeSeasonModal();
                }
            });

            // Allow Enter key in email input
            document.getElementById('emailInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    handleEmailSignIn();
                }
            });
        });

        // Media search and display functions
        async function searchMedia() {
            const query = document.getElementById('searchInput').value.trim();
            if (!query) return;
            
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = 
                '<div class="loading">' +
                    '<div class="spinner"></div>' +
                    '<p>Searching for "' + query + '"...</p>' +
                '</div>';
            
            try {
                const response = await fetch(TMDB_BASE_URL + '/search/' + currentMediaType + '?api_key=' + TMDB_API_KEY + '&query=' + encodeURIComponent(query));
                const data = await response.json();
                displayResults(data.results || []);
            } catch (error) {
                resultsDiv.innerHTML = 
                    '<div class="no-results">' +
                        '<h3>‚ùå Search Error</h3>' +
                        '<p>Unable to search. Please try again.</p>' +
                    '</div>';
            }
        }
        
        async function loadPopularContent() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = 
                '<div class="loading">' +
                    '<div class="spinner"></div>' +
                    '<p>Loading popular content...</p>' +
                '</div>';
            
            try {
                let results = [];
                
                if (currentMediaType === 'movie') {
                    const response = await fetch(TMDB_BASE_URL + '/movie/popular?api_key=' + TMDB_API_KEY);
                    if (!response.ok) throw new Error('API request failed');
                    const data = await response.json();
                    results = data.results.map(item => ({...item, media_type: 'movie'}));
                } else if (currentMediaType === 'tv') {
                    const response = await fetch(TMDB_BASE_URL + '/tv/popular?api_key=' + TMDB_API_KEY);
                    if (!response.ok) throw new Error('API request failed');
                    const data = await response.json();
                    results = data.results.map(item => ({...item, media_type: 'tv'}));
                } else {
                    const [moviesResponse, tvResponse] = await Promise.all([
                        fetch(TMDB_BASE_URL + '/movie/popular?api_key=' + TMDB_API_KEY),
                        fetch(TMDB_BASE_URL + '/tv/popular?api_key=' + TMDB_API_KEY)
                    ]);
                    
                    if (!moviesResponse.ok || !tvResponse.ok) throw new Error('API requests failed');
                    
                    const moviesData = await moviesResponse.json();
                    const tvData = await tvResponse.json();
                    
                    const combined = [
                        ...moviesData.results.slice(0, 10).map(item => ({...item, media_type: 'movie'})),
                        ...tvData.results.slice(0, 10).map(item => ({...item, media_type: 'tv'}))
                    ];
                    
                    for (let i = combined.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [combined[i], combined[j]] = [combined[j], combined[i]];
                    }
                    
                    results = combined.slice(0, 20);
                }
                
                displayResults(results);
                
            } catch (error) {
                console.error('Error loading popular content:', error);
                showSearchPrompt();
            }
        }

        function showSearchPrompt() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = 
                '<div class="no-results">' +
                    '<h3>üé¨ Welcome to Plex Request Portal</h3>' +
                    '<p>Search for your favorite movies and TV shows above to get started!</p>' +
                    '<br>' +
                    '<p style="color: #4ecdc4; font-size: 1rem; font-weight: 500;">Popular searches:</p>' +
                    '<div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 10px;">' +
                        '<button onclick="quickSearch(\'Avengers\')" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white; padding: 8px 16px; border-radius: 20px; cursor: pointer;">Avengers</button>' +
                        '<button onclick="quickSearch(\'Breaking Bad\')" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white; padding: 8px 16px; border-radius: 20px; cursor: pointer;">Breaking Bad</button>' +
                        '<button onclick="quickSearch(\'The Office\')" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white; padding: 8px 16px; border-radius: 20px; cursor: pointer;">The Office</button>' +
                        '<button onclick="quickSearch(\'Spider-Man\')" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white; padding: 8px 16px; border-radius: 20px; cursor: pointer;">Spider-Man</button>' +
                    '</div>' +
                '</div>';
        }

        function quickSearch(query) {
            document.getElementById('searchInput').value = query;
            searchMedia();
        }
        
        function displayResults(results) {
            const resultsDiv = document.getElementById('results');
            
            if (results.length === 0) {
                resultsDiv.innerHTML = 
                    '<div class="no-results">' +
                        '<h3>üîç No Results Found</h3>' +
                        '<p>Try a different search term.</p>' +
                    '</div>';
                return;
            }
            
            const grid = document.createElement('div');
            grid.className = 'results-grid';
            
            results.forEach(item => {
                const card = createMediaCard(item);
                grid.appendChild(card);
            });
            
            resultsDiv.innerHTML = '';
            resultsDiv.appendChild(grid);
        }
        
        function createMediaCard(item) {
            const card = document.createElement('div');
            card.className = 'media-card';
            
            const title = item.title || item.name;
            const year = item.release_date || item.first_air_date;
            const mediaType = item.media_type || currentMediaType;
            const mediaId = mediaType + '-' + item.id;
            
            const userRequest = userRequests.get(mediaId);
            let buttonText = 'Request ' + (mediaType === 'tv' ? 'Episodes' : 'Movie');
            let buttonClass = 'request-btn';
            let buttonDisabled = false;
            let episodeStatusHTML = '';
            
            // For TV shows, show requested episodes but don't disable button
            if (mediaType === 'tv' && userRequest && userRequest.selectedEpisodes) {
                const episodeInfo = formatRequestedEpisodes(userRequest.selectedEpisodes, userRequest.status);
                if (episodeInfo) {
                    episodeStatusHTML = `<div class="episode-status">${episodeInfo}</div>`;
                }
                // Keep button enabled for TV shows to allow multiple requests
                buttonText = 'Request More Episodes';
            } else if (mediaType === 'movie' && userRequest) {
                // For movies, disable button and show status
                buttonDisabled = true;
                switch (userRequest.status) {
                    case 'pending':
                        buttonText = 'Pending ‚è≥';
                        buttonClass = 'request-btn pending';
                        break;
                    case 'approved':
                        buttonText = 'Approved ‚úÖ';
                        buttonClass = 'request-btn approved';
                        break;
                    case 'not_available':
                        buttonText = 'Not Available üö´';
                        buttonClass = 'request-btn not_available';
                        break;
                    case 'no_storage':
                        buttonText = 'No Storage üíæ';
                        buttonClass = 'request-btn no_storage';
                        break;
                    case 'already_exists':
                        buttonText = 'Already Available üì¶';
                        buttonClass = 'request-btn already_exists';
                        break;
                    case 'downloading':
                        buttonText = 'Downloading ‚¨áÔ∏è';
                        buttonClass = 'request-btn downloading';
                        break;
                    case 'error':
                        buttonText = 'Error ‚ö†Ô∏è';
                        buttonClass = 'request-btn error';
                        break;
                }
            }
            
            // Check weekly limit (but not for TV shows that already have requests)
            if (!userRequest && userTier !== 'VIP' && userRequestCount >= weeklyLimit) {
                buttonDisabled = true;
                buttonText = 'Weekly Limit Reached';
            }
            
            let posterPath = item.poster_path ? 
                'https://image.tmdb.org/t/p/w500' + item.poster_path : 
                'https://via.placeholder.com/300x450/1a1a3a/ffffff?text=' + encodeURIComponent(title);
            
            card.innerHTML = 
                '<img src="' + posterPath + '" alt="' + title + '" class="media-poster">' +
                '<div class="media-info">' +
                    '<h3 class="media-title">' + title + '</h3>' +
                    '<p class="media-year">' + (year ? new Date(year).getFullYear() : 'Unknown') + ' ‚Ä¢ ' + (mediaType === 'tv' ? 'TV Show' : 'Movie') + '</p>' +
                    '<p class="media-overview">' + (item.overview || 'No description available.') + '</p>' +
                    episodeStatusHTML +
                    '<button class="' + buttonClass + '" id="btn-' + mediaId + '" ' + (buttonDisabled ? 'disabled' : '') + ' onclick="requestMedia(' + JSON.stringify(item).replace(/"/g, '&quot;') + ')">' +
                        buttonText +
                    '</button>' +
                '</div>';
            
            return card;
        }

        // New function to format requested episodes for display
        function formatRequestedEpisodes(episodeData, status) {
            if (!episodeData || Object.keys(episodeData).length === 0) {
                return null;
            }
            
            let statusClass = 'episode-status-item';
            if (status === 'pending') {
                statusClass += ' episode-status-pending';
            } else if (status === 'downloading') {
                statusClass += ' episode-status-downloading';
            } else if (status === 'error' || status === 'not_available') {
                statusClass += ' episode-status-error';
            }
            
            const formattedItems = [];
            
            for (const [season, episodes] of Object.entries(episodeData)) {
                if (!episodes || episodes.length === 0) continue;
                
                const seasonNum = season.replace('S', '');
                const sortedEpisodes = episodes.sort((a, b) => a - b);
                
                // Group consecutive episodes
                const ranges = [];
                let start = sortedEpisodes[0];
                let end = sortedEpisodes[0];
                
                for (let i = 1; i < sortedEpisodes.length; i++) {
                    if (sortedEpisodes[i] === end + 1) {
                        end = sortedEpisodes[i];
                    } else {
                        if (start === end) {
                            ranges.push(`E${String(start).padStart(2, '0')}`);
                        } else {
                            ranges.push(`E${String(start).padStart(2, '0')}-E${String(end).padStart(2, '0')}`);
                        }
                        start = sortedEpisodes[i];
                        end = sortedEpisodes[i];
                    }
                }
                
                // Add the last range
                if (start === end) {
                    ranges.push(`E${String(start).padStart(2, '0')}`);
                } else {
                    ranges.push(`E${String(start).padStart(2, '0')}-E${String(end).padStart(2, '0')}`);
                }
                
                // Format as S01: E01-E05, E07
                const seasonText = `${season}: ${ranges.join(', ')}`;
                formattedItems.push(`<span class="${statusClass}">${seasonText}</span>`);
            }
            
            const statusIcon = status === 'approved' ? '‚úÖ' : 
                             status === 'pending' ? '‚è≥' : 
                             status === 'downloading' ? '‚¨áÔ∏è' : 
                             status === 'error' ? '‚ùå' : '';
            
            return `<strong>Requested Episodes ${statusIcon}:</strong> ${formattedItems.join(' ')}`;
        }

        async function loadUserRequests() {
            if (!window.db || !currentUser) return;
            
            try {
                const requestsRef = window.collection(window.db, `artifacts/${APP_ID}/public/data/requests`);
                const snapshot = await window.getDocs(requestsRef);
                
                const userDocId = currentUser.email.replace(/[.@]/g, '_');
                
                snapshot.forEach((doc) => {
                    const data = doc.data();
                    if (data.userId === currentUser.id || data.userId === userDocId) {
                        const mediaId = data.mediaType + '-' + data.tmdbId;
                        
                        // For TV shows, merge multiple requests
                        if (data.mediaType === 'tv') {
                            const existingRequest = userRequests.get(mediaId);
                            if (existingRequest && existingRequest.selectedEpisodes) {
                                // Merge episodes from multiple requests
                                for (const [season, episodes] of Object.entries(data.selectedEpisodes || {})) {
                                    if (!existingRequest.selectedEpisodes[season]) {
                                        existingRequest.selectedEpisodes[season] = [];
                                    }
                                    existingRequest.selectedEpisodes[season] = [
                                        ...new Set([...existingRequest.selectedEpisodes[season], ...episodes])
                                    ].sort((a, b) => a - b);
                                }
                                // Update status to latest
                                if (data.status === 'approved' || existingRequest.status !== 'approved') {
                                    existingRequest.status = data.status;
                                }
                            } else {
                                userRequests.set(mediaId, data);
                            }
                        } else {
                            userRequests.set(mediaId, data);
                        }
                    }
                });
                
                console.log('Loaded user requests:', userRequests);
            } catch (error) {
                console.error('Error loading user requests:', error);
            }
        }

        async function listenForRequestUpdates() {
            if (!window.db || !currentUser) return;
            
            try {
                const requestsRef = window.collection(window.db, `artifacts/${APP_ID}/public/data/requests`);
                const userDocId = currentUser.email.replace(/[.@]/g, '_');
                
                window.onSnapshot(requestsRef, (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        const data = change.doc.data();
                        if ((data.userId === currentUser.id || data.userId === userDocId)) {
                            const mediaId = data.mediaType + '-' + data.tmdbId;
                            
                            if (change.type === 'modified' || change.type === 'added') {
                                // For TV shows, merge episodes
                                if (data.mediaType === 'tv') {
                                    const existingRequest = userRequests.get(mediaId);
                                    if (existingRequest && existingRequest.selectedEpisodes) {
                                        // Merge new episodes
                                        for (const [season, episodes] of Object.entries(data.selectedEpisodes || {})) {
                                            if (!existingRequest.selectedEpisodes[season]) {
                                                existingRequest.selectedEpisodes[season] = [];
                                            }
                                            existingRequest.selectedEpisodes[season] = [
                                                ...new Set([...existingRequest.selectedEpisodes[season], ...episodes])
                                            ].sort((a, b) => a - b);
                                        }
                                        existingRequest.status = data.status;
                                    } else {
                                        userRequests.set(mediaId, data);
                                    }
                                } else {
                                    userRequests.set(mediaId, data);
                                }
                                
                                // Update the display
                                updateMediaCardDisplay(mediaId);
                            }
                        }
                    });
                });
            } catch (error) {
                console.error('Error setting up request listener:', error);
            }
        }

        function updateMediaCardDisplay(mediaId) {
            // Find the media card and recreate it with updated info
            const button = document.getElementById('btn-' + mediaId);
            if (!button) return;
            
            const mediaCard = button.closest('.media-card');
            if (!mediaCard) return;
            
            const userRequest = userRequests.get(mediaId);
            if (!userRequest) return;
            
            // For TV shows, update the episode status display
            if (userRequest.mediaType === 'tv') {
                // Find or create episode status div
                let statusDiv = mediaCard.querySelector('.episode-status');
                if (!statusDiv) {
                    statusDiv = document.createElement('div');
                    statusDiv.className = 'episode-status';
                    button.parentNode.insertBefore(statusDiv, button);
                }
                
                const episodeInfo = formatRequestedEpisodes(userRequest.selectedEpisodes, userRequest.status);
                if (episodeInfo) {
                    statusDiv.innerHTML = episodeInfo;
                    statusDiv.style.display = 'block';
                }
                
                // Update button text but keep it enabled
                button.textContent = 'Request More Episodes';
                button.disabled = false;
            } else {
                // For movies, update button status
                updateButtonStatus(mediaId, userRequest.status);
            }
        }

        function updateButtonStatus(mediaId, status) {
            const button = document.getElementById('btn-' + mediaId);
            if (!button) return;
            
            button.disabled = true;
            button.className = 'request-btn ' + status;
            
            switch (status) {
                case 'pending':
                    button.textContent = 'Pending ‚è≥';
                    break;
                case 'approved':
                    button.textContent = 'Approved ‚úÖ';
                    break;
                case 'not_available':
                    button.textContent = 'Not Available üö´';
                    break;
                case 'no_storage':
                    button.textContent = 'No Storage üíæ';
                    break;
                case 'already_exists':
                    button.textContent = 'Already Available üì¶';
                    break;
                case 'downloading':
                    button.textContent = 'Downloading ‚¨áÔ∏è';
                    break;
                case 'error':
                    button.textContent = 'Error ‚ö†Ô∏è';
                    break;
            }
        }
    </script>
</body>
</html>