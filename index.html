<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Notflix Portal">
    <title>Plex Request Portal</title>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js';
        import { getFirestore, collection, addDoc, doc, getDoc, setDoc, updateDoc, onSnapshot, getDocs } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js';

        const firebaseConfig = {
            apiKey: "AIzaSyDjPme91T08wE2EU8zcY257PWhWVLff_2Y",
            authDomain: "plex-ab76b.firebaseapp.com",
            projectId: "plex-ab76b",
            storageBucket: "plex-ab76b.firebasestorage.app",
            messagingSenderId: "90028665456",
            appId: "1:90028665456:web:cb92b90922c42654bda2b5",
            measurementId: "G-37FFRXK89P"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        window.firebaseApp = app;
        window.db = db;
        window.collection = collection;
        window.addDoc = addDoc;
        window.doc = doc;
        window.getDoc = getDoc;
        window.setDoc = setDoc;
        window.updateDoc = updateDoc;
        window.onSnapshot = onSnapshot;
        window.getDocs = getDocs;

        console.log('🔥 Firebase initialized successfully');
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        input, textarea, button {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3a 50%, #2d1b4e 100%);
            color: #ffffff;
            min-height: 100vh;
            transition: all 0.3s ease;
            -webkit-overflow-scrolling: touch;
            position: relative;
            padding-bottom: env(safe-area-inset-bottom);
        }

        body.light-mode {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 50%, #dee2e6 100%);
            color: #212529;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            padding-top: max(20px, env(safe-area-inset-top));
            padding-bottom: max(20px, env(safe-area-inset-bottom));
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px 0;
            position: relative;
            padding-top: max(50px, env(safe-area-inset-top) + 30px);
        }

        .theme-toggle {
            position: absolute;
            top: max(10px, env(safe-area-inset-top) + 10px);
            right: 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 6px 12px;
            color: #ffffff;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            z-index: 100;
            min-width: 100px;
            justify-content: center;
        }

        .theme-toggle:hover, .theme-toggle:active {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(0.98);
        }

        .light-mode .theme-toggle {
            background: rgba(0, 0, 0, 0.1);
            border-color: rgba(0, 0, 0, 0.2);
            color: #212529;
        }

        .light-mode .theme-toggle:hover, .light-mode .theme-toggle:active {
            background: rgba(0, 0, 0, 0.2);
        }

        .beta-badge {
            position: absolute;
            top: max(10px, env(safe-area-inset-top) + 10px);
            left: 15px;
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
            color: white;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 2px 10px rgba(255, 107, 107, 0.3);
            animation: pulseGlow 2s infinite alternate;
            z-index: 100;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .light-mode .beta-badge {
            border-color: rgba(0, 0, 0, 0.1);
        }

        @keyframes pulseGlow {
            0% {
                box-shadow: 0 2px 10px rgba(255, 107, 107, 0.3);
                transform: scale(1);
            }
            100% {
                box-shadow: 0 4px 20px rgba(255, 107, 107, 0.6);
                transform: scale(1.02);
            }
        }

        .header h1 {
            font-size: clamp(1.6rem, 4.5vw, 2.5rem);
            font-weight: 700;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            padding: 0 130px;
        }

        .header-subtitle {
            font-size: clamp(0.85rem, 2.8vw, 1.1rem);
            color: #a0a0a0;
            font-weight: 300;
            padding: 0 20px;
            line-height: 1.4;
        }

        .light-mode .header-subtitle {
            color: #6c757d;
        }

        .search-section {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .light-mode .search-section {
            background: rgba(255, 255, 255, 0.7);
            border-color: rgba(0, 0, 0, 0.1);
        }

        .search-container {
            position: relative;
            margin-bottom: 20px;
        }

        .search-input {
            width: 100%;
            padding: 16px 60px 16px 20px;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            color: #ffffff;
            outline: none;
            transition: all 0.3s ease;
            -webkit-appearance: none;
            -webkit-tap-highlight-color: transparent;
        }

        .light-mode .search-input {
            background: rgba(255, 255, 255, 0.9);
            border-color: rgba(0, 0, 0, 0.2);
            color: #212529;
        }

        .search-input:focus {
            border-color: #4ecdc4;
            background: rgba(255, 255, 255, 0.15);
        }

        .light-mode .search-input:focus {
            background: rgba(255, 255, 255, 1);
        }

        .search-input::placeholder {
            color: #a0a0a0;
        }

        .search-btn {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border: none;
            padding: 12px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1.2rem;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .search-btn:active {
            transform: translateY(-50%) scale(0.95);
        }

        .media-type-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .media-type-btn {
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.95rem;
            font-weight: 500;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            min-width: 80px;
        }

        .light-mode .media-type-btn {
            background: rgba(0, 0, 0, 0.05);
            border-color: rgba(0, 0, 0, 0.2);
            color: #212529;
        }

        .media-type-btn.active {
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
            border-color: #ff6b6b;
        }

        .media-type-btn:active {
            transform: scale(0.95);
        }

        .movies-section, .tv-section {
            margin-bottom: 40px;
            transition: all 0.3s ease;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 30px 0 20px 0;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            flex-wrap: wrap;
            gap: 10px;
        }

        .light-mode .section-header {
            border-bottom-color: rgba(0, 0, 0, 0.1);
        }

        .section-title {
            font-size: clamp(1.3rem, 4vw, 1.8rem);
            font-weight: 600;
            color: #4ecdc4;
        }

        .section-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .view-all-btn {
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.3s ease;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            white-space: nowrap;
        }

        .view-all-btn:hover, .view-all-btn:active {
            transform: translateY(-2px) scale(0.98);
            box-shadow: 0 4px 12px rgba(78, 205, 196, 0.3);
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .media-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            overflow: hidden;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            -webkit-tap-highlight-color: transparent;
        }

        .light-mode .media-card {
            background: rgba(255, 255, 255, 0.8);
            border-color: rgba(0, 0, 0, 0.1);
        }

        .media-card:active {
            transform: scale(0.98);
        }

        .media-poster {
            width: 100%;
            height: 240px;
            object-fit: cover;
            display: block;
        }

        .media-info {
            padding: 12px;
        }

        .media-title {
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 6px;
            color: #ffffff;
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .light-mode .media-title {
            color: #212529;
        }

        .media-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            flex-wrap: wrap;
            gap: 5px;
        }

        .media-year {
            color: #4ecdc4;
            font-weight: 500;
            font-size: 0.85rem;
        }

        .media-type-badge {
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .media-overview {
            color: #a0a0a0;
            font-size: 0.75rem;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .light-mode .media-overview {
            color: #6c757d;
        }

        .request-btn {
            width: 100%;
            padding: 10px 8px;
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border: none;
            border-radius: 8px;
            color: #ffffff;
            font-weight: 600;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .request-btn:active {
            transform: scale(0.98);
        }

        .request-btn:disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }

        .request-btn.pending {
            background: linear-gradient(45deg, #808080, #696969);
        }

        .request-btn.approved {
            background: linear-gradient(45deg, #28a745, #218838);
        }

        .request-btn.not_available {
            background: linear-gradient(45deg, #ff0000, #dc143c);
        }

        .request-btn.no_storage {
            background: linear-gradient(45deg, #ffa500, #ff8c00);
        }

        .request-btn.already_exists {
            background: linear-gradient(45deg, #00ffff, #1e90ff);
        }

        .request-btn.downloading {
            background: linear-gradient(45deg, #0099ff, #007acc);
        }

        .request-btn.error {
            background: linear-gradient(45deg, #ff6b6b, #ff4444);
        }

        .user-info {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            flex-wrap: wrap;
            gap: 15px;
        }

        .light-mode .user-info {
            background: rgba(255, 255, 255, 0.7);
            border-color: rgba(0, 0, 0, 0.1);
        }

        .user-info.signed-out {
            justify-content: center;
            text-align: center;
        }

        .sign-in-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
        }

        .sign-in-prompt {
            color: #a0a0a0;
            font-size: 1rem;
        }

        .light-mode .sign-in-prompt {
            color: #6c757d;
        }

        .test-signin-btn {
            background: #ffffff;
            color: #333;
            border: 1px solid #dadce0;
            padding: 12px 24px;
            border-radius: 4px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            font-size: 14px;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .test-signin-btn:active {
            transform: scale(0.98);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            background: #fafafa;
        }

        .email-input {
            width: 100%;
            max-width: 300px;
            padding: 12px 16px;
            font-size: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            margin-bottom: 15px;
            outline: none;
            transition: all 0.3s ease;
            -webkit-appearance: none;
        }

        .email-input:focus {
            border-color: #4ecdc4;
            background: rgba(255, 255, 255, 0.15);
        }

        .email-input::placeholder {
            color: #a0a0a0;
        }

        .light-mode .email-input {
            background: rgba(255, 255, 255, 0.9);
            border-color: rgba(0, 0, 0, 0.3);
            color: #212529;
        }

        .light-mode .email-input:focus {
            background: rgba(255, 255, 255, 1);
        }

        .user-tier {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-left: 8px;
        }

        .tier-STANDARD {
            background: linear-gradient(45deg, #6c757d, #495057);
            color: #ffffff;
        }

        .tier-PRO {
            background: linear-gradient(45deg, #9b59b6, #8e44ad);
            color: #ffffff;
        }

        .tier-VIP {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #212529;
        }

        .vip-badge {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #212529;
            padding: 3px 6px;
            border-radius: 8px;
            font-size: 0.65rem;
            font-weight: bold;
            margin-left: 6px;
        }

        .content-locked {
            filter: blur(5px);
            pointer-events: none;
            opacity: 0.5;
        }

        .no-results {
            text-align: center;
            padding: 40px 20px;
            color: #a0a0a0;
        }

        .no-results h3 {
            font-size: 1.3rem;
            margin-bottom: 10px;
            color: #ffffff;
        }

        .light-mode .no-results h3 {
            color: #212529;
        }

        .loading {
            text-align: center;
            padding: 40px 20px;
            color: #a0a0a0;
        }

        .light-mode .loading {
            color: #6c757d;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-left: 3px solid #4ecdc4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .page-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ffffff;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            font-size: 0.9rem;
            min-width: 40px;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .light-mode .page-btn {
            background: rgba(0, 0, 0, 0.05);
            border-color: rgba(0, 0, 0, 0.2);
            color: #212529;
        }

        .page-btn:active {
            transform: scale(0.95);
        }

        .page-btn.active {
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border-color: #4ecdc4;
        }

        .page-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .page-info {
            color: #a0a0a0;
            font-size: 0.85rem;
            text-align: center;
            width: 100%;
            margin-top: 5px;
        }

        .light-mode .page-info {
            color: #6c757d;
        }

        /* Mobile-specific adjustments */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
                padding-top: max(15px, env(safe-area-inset-top));
            }
            
            .header {
                margin-bottom: 20px;
                padding: 15px 0;
                padding-top: max(45px, env(safe-area-inset-top) + 25px);
            }
            
            .theme-toggle {
                top: max(8px, env(safe-area-inset-top) + 8px);
                right: 10px;
                padding: 5px 8px;
                font-size: 0.75rem;
                gap: 4px;
                min-width: 80px;
                border-radius: 15px;
            }
            
            .beta-badge {
                top: max(8px, env(safe-area-inset-top) + 8px);
                left: 10px;
                padding: 5px 8px;
                font-size: 0.7rem;
                border-radius: 12px;
            }
            
            .header h1 {
                padding: 0 100px;
                font-size: clamp(1.4rem, 6vw, 2rem);
            }
            
            .header-subtitle {
                font-size: clamp(0.8rem, 3.5vw, 0.95rem);
                padding: 0 15px;
            }
            
            .search-section {
                padding: 15px;
                margin-bottom: 20px;
            }
            
            .results-grid {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
                gap: 12px;
            }
            
            .media-poster {
                height: 200px;
            }
            
            .media-info {
                padding: 10px;
            }
            
            .media-title {
                font-size: 0.9rem;
            }
            
            .section-header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
                margin: 20px 0 15px 0;
            }
            
            .section-controls {
                justify-content: center;
            }
            
            .user-info {
                flex-direction: column;
                gap: 15px;
                text-align: center;
                padding: 15px;
            }
        }

        /* Extra small mobile devices */
        @media (max-width: 480px) {
            .header h1 {
                padding: 0 90px;
                font-size: 1.3rem;
            }
            
            .theme-toggle {
                min-width: 70px;
                padding: 4px 6px;
            }
            
            .theme-toggle span {
                font-size: 0.7rem;
            }
            
            .beta-badge {
                padding: 4px 6px;
                font-size: 0.65rem;
            }
            
            .results-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                gap: 10px;
            }
        }

        /* iPhone X and newer notch support */
        @supports (padding: max(0px)) {
            .container {
                padding-left: max(20px, env(safe-area-inset-left));
                padding-right: max(20px, env(safe-area-inset-right));
            }
            
            @media (max-width: 768px) {
                .container {
                    padding-left: max(15px, env(safe-area-inset-left));
                    padding-right: max(15px, env(safe-area-inset-right));
                }
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="beta-badge">⚡ BETA</div>
            <button class="theme-toggle" onclick="toggleTheme()">
                <span id="themeIcon">🌙</span>
                <span id="themeText">Light</span>
            </button>
            <h1>🎬 Notflix Request Portal</h1>
            <p class="header-subtitle">Request your favorite movies and TV shows for our Plex server</p>
        </div>

        <div class="user-info signed-out" id="userInfo">
            <div class="sign-in-section">
                <p class="sign-in-prompt">Sign in to request movies and TV shows</p>
                
                <!-- Google Sign-In Button -->
                <div id="g_id_onload"
                     data-client_id="90028665456-2hbgv8ou7hjr4pjh2pq2v5t21oflfdc8.apps.googleusercontent.com"
                     data-context="signin"
                     data-ux_mode="popup"
                     data-callback="handleCredentialResponse"
                     data-auto_prompt="false">
                </div>
                <div class="g_id_signin"
                     data-type="standard"
                     data-shape="pill"
                     data-theme="filled_blue"
                     data-text="signin_with"
                     data-size="large"
                     data-logo_alignment="left">
                </div>
                
                <!-- Email Sign-In -->
                <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.2);">
                    <p style="font-size: 0.9rem; color: #a0a0a0; margin-bottom: 15px;">Or sign in with email:</p>
                    <input type="email" class="email-input" id="emailInput" placeholder="Enter your authorized email">
                    <button class="test-signin-btn" onclick="handleEmailSignIn()">
                        <svg width="16" height="16" viewBox="0 0 24 24" style="margin-right: 8px;">
                            <path fill="currentColor" d="M20,8L12,13L4,8V6L12,11L20,6M20,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6C2,4.89 21.1,4 20,4Z"/>
                        </svg>
                        Email Sign In
                    </button>
                    <p style="font-size: 0.75rem; color: #666; margin-top: 8px;">
                        Only authorized emails can access this system
                    </p>
                </div>
            </div>
        </div>

        <div class="search-section content-locked">
            <div class="search-container">
                <input type="text" class="search-input" id="searchInput" placeholder="Search for movies and TV shows...">
                <button class="search-btn" id="searchBtn">🔍</button>
            </div>
            
            <div class="media-type-selector">
                <button class="media-type-btn active" data-type="multi" onclick="changeMediaType('multi')">All</button>
                <button class="media-type-btn" data-type="movie" onclick="changeMediaType('movie')">Movies</button>
                <button class="media-type-btn" data-type="tv" onclick="changeMediaType('tv')">TV Shows</button>
            </div>
        </div>

        <div id="mainContent" class="content-locked">
            <!-- Popular Movies Section -->
            <div class="movies-section" id="moviesSection">
                <div class="section-header">
                    <h2 class="section-title">🍿 Popular Movies</h2>
                    <div class="section-controls">
                        <button class="view-all-btn" onclick="loadMoreMovies()" id="loadMoreMoviesBtn">Load More</button>
                        <button class="view-all-btn" onclick="showAllMovies()">View All Movies</button>
                    </div>
                </div>
                <div id="popularMovies" class="results-grid">
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Loading popular movies...</p>
                    </div>
                </div>
            </div>

            <!-- Popular TV Shows Section -->
            <div class="tv-section" id="tvSection">
                <div class="section-header">
                    <h2 class="section-title">📺 Popular TV Shows</h2>
                    <div class="section-controls">
                        <button class="view-all-btn" onclick="loadMoreTVShows()" id="loadMoreTVBtn">Load More</button>
                        <button class="view-all-btn" onclick="showAllTVShows()">View All TV Shows</button>
                    </div>
                </div>
                <div id="popularTVShows" class="results-grid">
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Loading popular TV shows...</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Search Results Section - MOVED OUTSIDE mainContent -->
        <div id="searchResults" class="results-grid" style="display: none;"></div>
    </div>

    <!-- Episode Selection Modal -->
    <div id="seasonModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 1000; padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #1a1a3a 0%, #2d1b4e 100%); padding: 25px; border-radius: 20px; border: 1px solid rgba(255, 255, 255, 0.2); max-width: 95vw; width: 90%; max-height: 80vh; overflow-y: auto; transition: all 0.3s ease; -webkit-overflow-scrolling: touch;">
            <h3 style="margin-bottom: 20px; color: #ffffff; font-size: 1.3rem;">Select Episodes</h3>
            <p style="color: #a0a0a0; margin-bottom: 20px;">Choose which episodes you'd like to request:</p>
            <div id="seasonContent">
                <div style="text-align: center; padding: 20px; color: #a0a0a0;">
                    <div class="spinner"></div>
                    <p>Loading episode information...</p>
                </div>
            </div>
            <div id="selectionSummary" style="display: none; margin-top: 20px; padding: 15px; background: rgba(78, 205, 196, 0.1); border-radius: 8px; border: 1px solid rgba(78, 205, 196, 0.3);">
                <div style="font-size: 1rem; font-weight: 600; color: #4ecdc4; margin-bottom: 10px;">Selection Summary</div>
                <div id="summaryText" style="font-size: 0.9rem; line-height: 1.6; color: #ffffff;"></div>
            </div>
            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 25px; flex-wrap: wrap;">
                <button onclick="closeSeasonModal()" style="padding: 12px 20px; border: none; border-radius: 10px; cursor: pointer; font-weight: 600; font-size: 0.9rem; -webkit-tap-highlight-color: transparent; touch-action: manipulation; flex: 1; min-width: 100px; background: rgba(255, 255, 255, 0.1); color: #ffffff;">Cancel</button>
                <button onclick="confirmRequest()" style="padding: 12px 20px; border: none; border-radius: 10px; cursor: pointer; font-weight: 600; font-size: 0.9rem; -webkit-tap-highlight-color: transparent; touch-action: manipulation; flex: 1; min-width: 100px; background: linear-gradient(45deg, #4ecdc4, #45b7d1); color: #ffffff;">Request Selected</button>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const TMDB_API_KEY = 'df968e81859a06cdd6e642da1684ecf9';
        const TMDB_BASE_URL = 'https://api.themoviedb.org/3';
        const APP_ID = '1403586588985921587';
        let currentMediaType = 'multi';
        let currentUser = null;
        let userRequestCount = 0;
        let userRequests = new Map();
        let userTier = 'STANDARD';
        let weeklyLimit = 5;
        let selectedMedia = null;
        let selectedEpisodes = {};
        let tvShowDetails = null;
        let currentBrowseType = '';
        let currentPage = 1;
        let totalPages = 10;
        let moviesLoaded = 0;
        let tvShowsLoaded = 0;
        let allMovies = [];
        let allTVShows = [];

        const USER_TIERS = {
            'STANDARD': { name: 'Standard', requests: 5, color: 'tier-STANDARD' },
            'PRO': { name: 'Pro', requests: 20, color: 'tier-PRO' },
            'VIP': { name: 'VIP', requests: -1, color: 'tier-VIP' }
        };

        // Enhanced touch event handling for better iOS compatibility
        function addTouchSupport() {
            document.addEventListener('touchstart', function(e) {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }
            }, { passive: true });

            document.addEventListener('touchmove', function(e) {
                // Allow normal scrolling
            }, { passive: true });

            window.addEventListener('orientationchange', function() {
                setTimeout(function() {
                    document.body.style.height = window.innerHeight + 'px';
                    setTimeout(function() {
                        document.body.style.height = '';
                    }, 100);
                }, 500);
            });
        }

        // Check for saved session on page load
        function checkSavedSession() {
            const savedUser = localStorage.getItem('plexUser');
            if (savedUser) {
                try {
                    currentUser = JSON.parse(savedUser);
                    console.log('📄 Restored user session:', currentUser.email);
                    updateUIForSignedInUser();
                    return true;
                } catch (error) {
                    console.error('Error restoring session:', error);
                    localStorage.removeItem('plexUser');
                }
            }
            return false;
        }

        // Save user session
        function saveUserSession(user) {
            localStorage.setItem('plexUser', JSON.stringify(user));
        }

        // Google Sign-In callback
        function handleCredentialResponse(response) {
            console.log('🔐 Google Sign-In response received');
            
            try {
                const responsePayload = decodeJwtResponse(response.credential);
                console.log('✅ Decoded user info:', responsePayload);
                
                const tempUser = {
                    id: responsePayload.sub,
                    name: responsePayload.name,
                    email: responsePayload.email.toLowerCase(),
                    picture: responsePayload.picture,
                    provider: 'google'
                };
                
                checkUserAuthorization(tempUser);
                
            } catch (error) {
                console.error('❌ Error handling Google sign-in:', error);
                alert('Google Sign-In failed. Please try the email sign-in option.');
            }
        }

        function decodeJwtResponse(token) {
            const base64Url = token.split('.')[1];
            const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
            const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
            }).join(''));
            return JSON.parse(jsonPayload);
        }

        // Email-based sign in
        async function handleEmailSignIn() {
            console.log('📧 Email sign-in started');
            const emailInput = document.getElementById('emailInput');
            if (!emailInput) {
                alert('Email input not found');
                return;
            }
            
            const email = emailInput.value.trim().toLowerCase();
            
            if (!email) {
                alert('Please enter an email address');
                return;
            }

            if (!email.includes('@')) {
                alert('Please enter a valid email address');
                return;
            }

            console.log('📧 Attempting sign-in for:', email);

            const tempUser = {
                id: 'email_' + email.replace(/[.@]/g, '_'),
                name: email.split('@')[0],
                email: email,
                picture: createUserAvatar(email.charAt(0).toUpperCase()),
                provider: 'email'
            };

            console.log('👤 Created temp user:', tempUser);
            await checkUserAuthorization(tempUser);
        }

        // Create user avatar
        function createUserAvatar(initial) {
            return `data:image/svg+xml;base64,${btoa(`
                <svg width="50" height="50" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="25" cy="25" r="25" fill="#4ecdc4"/>
                    <text x="25" y="30" font-family="Arial" font-size="20" fill="white" text-anchor="middle" font-weight="bold">
                        ${initial}
                    </text>
                </svg>
            `)}`;
        }

        // Check user authorization
        async function checkUserAuthorization(tempUser) {
            console.log('🔐 Checking authorization for:', tempUser.email);
            
            // Update button state
            const emailSignInBtn = document.querySelector('[onclick="handleEmailSignIn()"]');
            if (emailSignInBtn) {
                emailSignInBtn.innerHTML = 'Checking authorization...';
                emailSignInBtn.disabled = true;
            }

            try {
                console.log('🔗 Checking Firebase connection...');
                if (!window.db) {
                    console.error('❌ Firebase not initialized');
                    showAuthorizationError('Firebase connection failed. Please refresh the page.');
                    return;
                }

                const userDocId = tempUser.email.replace(/[.@]/g, '_');
                console.log('📄 Looking for user document:', userDocId);
                
                const userDocRef = window.doc(window.db, `artifacts/${APP_ID}/public/data/users`, userDocId);
                const userDoc = await window.getDoc(userDocRef);
                
                console.log('📄 User document exists:', userDoc.exists());
                
                if (!userDoc.exists()) {
                    console.log('❌ User not found in database');
                    showAuthorizationError('Your email is not in the authorized users list.\n\nTo get access:\n1. Contact an admin to add your email\n2. Wait for authorization to be processed\n3. Try signing in again');
                    return;
                }
                
                const userData = userDoc.data();
                console.log('✅ Found user data:', userData);
                
                if (!userData.tier && !userData.placeholder && !userData.createdBy) {
                    console.log('❌ User data incomplete');
                    showAuthorizationError('Your email exists but is not properly authorized.\n\nPlease contact an administrator.');
                    return;
                }

                currentUser = {
                    ...tempUser,
                    id: userDocId,
                    authorized: true,
                    authorizedAt: new Date().toISOString()
                };

                console.log('✅ User authorized successfully:', currentUser.email);
                saveUserSession(currentUser);
                updateUIForSignedInUser();

            } catch (error) {
                console.error('❌ Authorization check failed:', error);
                showAuthorizationError('Error checking authorization: ' + error.message + '\n\nPlease try again.');
            }
        }

        function showAuthorizationError(message) {
            alert('⛔ Access Denied\n\n' + message);
            
            // Reset button
            const emailSignInBtn = document.querySelector('[onclick="handleEmailSignIn()"]');
            if (emailSignInBtn) {
                emailSignInBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" style="margin-right: 8px;"><path fill="currentColor" d="M20,8L12,13L4,8V6L12,11L20,6M20,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6C2,4.89 21.1,4 20,4Z"/></svg>Email Sign In';
                emailSignInBtn.disabled = false;
            }
            
            // Clear email input
            const emailInput = document.getElementById('emailInput');
            if (emailInput) {
                emailInput.value = '';
            }
        }

        function updateUIForSignedInUser() {
            const userInfo = document.getElementById('userInfo');
            userInfo.className = 'user-info';
            
            userInfo.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; width: 100%;">
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <img src="${currentUser.picture}" alt="${currentUser.name}" style="width: 50px; height: 50px; border-radius: 50%; border: 2px solid #4ecdc4;">
                        <div>
                            <div style="font-weight: 600; font-size: 1.1rem; color: #ffffff;">
                                ${currentUser.name} 
                                <span style="background: linear-gradient(45deg, #ffd700, #ffed4e); color: #212529; padding: 4px 8px; border-radius: 8px; font-size: 0.7rem; margin-left: 8px;">Loading...</span>
                            </div>
                            <div style="color: #a0a0a0; font-size: 0.9rem;">${currentUser.email}</div>
                        </div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <div style="background: linear-gradient(45deg, #ff6b6b, #ff8e53); padding: 8px 16px; border-radius: 15px; font-weight: 600;">
                            Loading...
                        </div>
                        <button onclick="signOut()" style="background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.2); padding: 8px 16px; border-radius: 8px; cursor: pointer;">
                            Sign Out
                        </button>
                    </div>
                </div>
            `;
            
            // Unlock content
            document.querySelectorAll('.content-locked').forEach(el => {
                el.classList.remove('content-locked');
            });
            
            // Load user data and setup listeners
            loadUserData();
            loadUserRequests();
            listenForRequestUpdates();
            
            // Load content
            loadPopularContent();
            
            console.log('✅ UI updated for signed-in user');
        }

        // Load user data from Firebase
        async function loadUserData() {
            try {
                if (!window.db || !currentUser) return;
                
                const userDocRef = window.doc(window.db, `artifacts/${APP_ID}/public/data/users`, currentUser.id);
                const userDoc = await window.getDoc(userDocRef);
                
                if (userDoc.exists()) {
                    const userData = userDoc.data();
                    userTier = userData.tier || 'STANDARD';
                    userRequestCount = userData.requestCount || 0;
                    weeklyLimit = userData.weeklyLimit || USER_TIERS[userTier].requests;
                } else {
                    userTier = 'STANDARD';
                    weeklyLimit = USER_TIERS[userTier].requests;
                    userRequestCount = 0;
                    
                    await window.setDoc(userDocRef, {
                        email: currentUser.email,
                        name: currentUser.name,
                        tier: userTier,
                        requestCount: 0,
                        weeklyLimit: weeklyLimit,
                        lastResetDate: new Date(),
                        isVIP: userTier === 'VIP'
                    });
                }
                
                updateUserInfoDisplay();
                setupUserDataListener();
                
            } catch (error) {
                console.error('Error loading user data:', error);
                userTier = 'STANDARD';
                weeklyLimit = 5;
                userRequestCount = 0;
                updateUserInfoDisplay();
            }
        }

        function setupUserDataListener() {
            if (!window.db || !currentUser) return;
            
            try {
                const userDocId = currentUser.email.replace(/[.@]/g, '_');
                const userDocRef = window.doc(window.db, `artifacts/${APP_ID}/public/data/users`, userDocId);
                
                window.onSnapshot(userDocRef, (doc) => {
                    if (doc.exists()) {
                        const userData = doc.data();
                        const oldTier = userTier;
                        
                        userTier = userData.tier || 'STANDARD';
                        userRequestCount = userData.requestCount || 0;
                        weeklyLimit = userData.weeklyLimit || USER_TIERS[userTier].requests;
                        
                        updateUserInfoDisplay();
                        
                        if (oldTier !== userTier) {
                            showTierUpgradeNotification(oldTier, userTier);
                        }
                        
                        console.log(`📄 User data updated: ${userTier} tier, ${userRequestCount}/${weeklyLimit} requests`);
                    }
                }, (error) => {
                    console.error('Error listening to user data:', error);
                });
                
            } catch (error) {
                console.error('Error setting up user data listener:', error);
            }
        }

        function showTierUpgradeNotification(oldTier, newTier) {
            const tierConfig = USER_TIERS[newTier];
            const message = newTier === 'VIP' ? 
                '🎉 Congratulations! You\'ve been upgraded to VIP status with unlimited requests! 👑' :
                `🎉 Your account has been upgraded to ${tierConfig.name} tier with ${tierConfig.requests} weekly requests!`;
            
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: max(20px, env(safe-area-inset-top));
                right: max(20px, env(safe-area-inset-right));
                background: linear-gradient(45deg, #4ecdc4, #45b7d1);
                color: white;
                padding: 15px 20px;
                border-radius: 10px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                z-index: 10000;
                max-width: 300px;
                font-weight: 600;
                animation: slideIn 0.3s ease-out;
            `;
            
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease-in';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 5000);
        }

        function updateUserInfoDisplay() {
            const tierConfig = USER_TIERS[userTier];
            const remainingRequests = weeklyLimit === -1 ? '∞' : Math.max(0, weeklyLimit - userRequestCount);
            
            const userInfo = document.getElementById('userInfo');
            userInfo.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; width: 100%;">
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <img src="${currentUser.picture}" alt="${currentUser.name}" style="width: 50px; height: 50px; border-radius: 50%; border: 2px solid #4ecdc4;">
                        <div>
                            <div style="font-weight: 600; font-size: 1.1rem; color: #ffffff;">
                                ${currentUser.name} 
                                <span class="user-tier ${tierConfig.color}">${tierConfig.name}${userTier === 'VIP' ? ' 👑' : ''}</span>
                            </div>
                            <div style="color: #a0a0a0; font-size: 0.9rem;">${currentUser.email}</div>
                        </div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <div style="background: linear-gradient(45deg, #ff6b6b, #ff8e53); padding: 8px 16px; border-radius: 15px; font-weight: 600;">
                            ${remainingRequests} requests remaining
                        </div>
                        <button onclick="signOut()" style="background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.2); padding: 8px 16px; border-radius: 8px; cursor: pointer;">
                            Sign Out
                        </button>
                    </div>
                </div>
            `;
        }

        function signOut() {
            localStorage.removeItem('plexUser');
            currentUser = null;
            location.reload();
        }

        function toggleTheme() {
            document.body.classList.toggle('light-mode');
            const isLight = document.body.classList.contains('light-mode');
            
            document.getElementById('themeIcon').textContent = isLight ? '☀️' : '🌙';
            document.getElementById('themeText').textContent = isLight ? 'Dark' : 'Light';
            
            localStorage.setItem('theme', isLight ? 'light' : 'dark');
        }

        // WORKING SEARCH FUNCTION (from your working code)
        async function searchMedia() {
            console.log('🔍 searchMedia() function called');
            
            // Check if user is signed in
            if (!currentUser) {
                console.log('❌ User not signed in');
                alert('Please sign in to search for content');
                return;
            }
            
            const searchInput = document.getElementById('searchInput');
            if (!searchInput) {
                console.error('❌ Search input element not found');
                return;
            }
            
            const query = searchInput.value.trim();
            console.log('🔍 Search query:', query);
            
            if (!query) {
                alert('Please enter a search term');
                return;
            }

            console.log('🔍 Searching for:', query);
            
            const searchResults = document.getElementById('searchResults');
            const mainContent = document.getElementById('mainContent');
            
            console.log('🔍 Elements found:', {
                searchResults: !!searchResults,
                mainContent: !!mainContent
            });
            
            if (!searchResults || !mainContent) {
                console.error('❌ Required elements not found');
                return;
            }
            
            // Show search results, hide main content
            console.log('🔍 Hiding main content and showing search results...');
            mainContent.style.display = 'none';
            searchResults.style.display = 'grid';
            searchResults.className = 'results-grid active';
            
            searchResults.innerHTML = '<div class="loading"><div class="spinner"></div><p>Searching...</p></div>';
            
            console.log('🔍 Search results should now be visible');

            try {
                let allResults = [];
                
                console.log('🔍 Current media type:', currentMediaType);
                console.log('🔍 TMDB API Key present:', !!TMDB_API_KEY);
                console.log('🔍 TMDB Base URL:', TMDB_BASE_URL);
                
                if (currentMediaType === 'multi') {
                    console.log('🎭 Searching both movies and TV shows');
                    
                    const movieUrl = `${TMDB_BASE_URL}/search/movie?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(query)}`;
                    const tvUrl = `${TMDB_BASE_URL}/search/tv?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(query)}`;
                    
                    console.log('🔍 Movie URL:', movieUrl);
                    console.log('🔍 TV URL:', tvUrl);
                    
                    // Search both movies and TV
                    const [movieResponse, tvResponse] = await Promise.all([
                        fetch(movieUrl),
                        fetch(tvUrl)
                    ]);
                    
                    console.log('🔍 Movie response status:', movieResponse.status, movieResponse.ok);
                    console.log('🔍 TV response status:', tvResponse.status, tvResponse.ok);
                    
                    const [movieData, tvData] = await Promise.all([movieResponse.json(), tvResponse.json()]);
                    
                    console.log('🔍 Movie data:', movieData);
                    console.log('🔍 TV data:', tvData);
                    
                    const movies = movieData.results?.map(item => ({...item, media_type: 'movie'})) || [];
                    const tvShows = tvData.results?.map(item => ({...item, media_type: 'tv'})) || [];
                    allResults = [...movies, ...tvShows];
                    
                    console.log('🔍 Movies found:', movies.length);
                    console.log('🔍 TV shows found:', tvShows.length);
                } else {
                    console.log(`🎯 Searching ${currentMediaType} only`);
                    
                    const searchUrl = `${TMDB_BASE_URL}/search/${currentMediaType}?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(query)}`;
                    console.log('🔍 Search URL:', searchUrl);
                    
                    // Search specific type
                    const response = await fetch(searchUrl);
                    console.log('🔍 Response status:', response.status, response.ok);
                    
                    const data = await response.json();
                    console.log('🔍 Response data:', data);
                    
                    allResults = data.results?.map(item => ({...item, media_type: currentMediaType})) || [];
                }

                console.log('🔍 Total search results:', allResults.length);
                console.log('🔍 All results array:', allResults);

                if (allResults.length > 0) {
                    console.log('✅ Calling displayResults with', allResults.length, 'items');
                    displayResults(allResults, searchResults);
                    console.log('✅ displayResults completed');
                } else {
                    console.log('❌ No results found, showing no-results message');
                    searchResults.innerHTML = '<div class="no-results"><h3>🔍 No Results Found</h3><p>Try a different search term.</p></div>';
                }

            } catch (error) {
                console.error('❌ Search error:', error);
                console.error('❌ Error stack:', error.stack);
                searchResults.innerHTML = '<div class="no-results"><h3>⚠️ Search Error</h3><p>Please try again.</p></div>';
            }
        }

        // Remove the old performSearch alias to avoid confusion
        // ALIAS FOR BACKWARDS COMPATIBILITY - REMOVED

        // Enhanced Media type switching with proper filtering
        function changeMediaType(type) {
            console.log('🎬 changeMediaType() called with:', type);
            
            currentMediaType = type;
            console.log('🎬 Updated currentMediaType to:', currentMediaType);
            
            // Update button styles
            document.querySelectorAll('.media-type-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.type === type) {
                    btn.classList.add('active');
                    console.log('🎬 Activated button for type:', type);
                }
            });
            
            // Hide search results and show main content
            document.getElementById('searchResults').style.display = 'none';
            document.getElementById('mainContent').style.display = 'block';
            
            // Filter the displayed content based on selected type
            filterContentSections(type);
        }

        // New function to show/hide entire sections based on media type
        function filterContentSections(type) {
            console.log('🔍 Filtering sections for:', type);
            
            // Get the section containers by their IDs
            const moviesSection = document.getElementById('moviesSection');
            const tvSection = document.getElementById('tvSection');
            
            // Show/hide entire sections based on type
            switch(type) {
                case 'movie':
                    console.log('🎥️ Showing only movies');
                    if (moviesSection) moviesSection.style.display = 'block';
                    if (tvSection) tvSection.style.display = 'none';
                    break;
                    
                case 'tv':
                    console.log('📺 Showing only TV shows');
                    if (moviesSection) moviesSection.style.display = 'none';
                    if (tvSection) tvSection.style.display = 'block';
                    break;
                    
                case 'multi':
                default:
                    console.log('🎭 Showing both movies and TV shows');
                    if (moviesSection) moviesSection.style.display = 'block';
                    if (tvSection) tvSection.style.display = 'block';
                    break;
            }
            
            console.log('✅ Content sections filtered for:', type);
        }

        // Enhanced content loading
        async function loadPopularContent() {
            await Promise.all([
                loadPopularMovies(),
                loadPopularTVShows()
            ]);
        }

        async function loadPopularMovies() {
            const moviesDiv = document.getElementById('popularMovies');
            moviesDiv.innerHTML = '<div class="loading"><div class="spinner"></div><p>Loading popular movies...</p></div>';
            
            try {
                // Fetch from multiple pages to get more content
                const [page1, page2, page3] = await Promise.all([
                    fetch(`${TMDB_BASE_URL}/movie/popular?api_key=${TMDB_API_KEY}&page=1`),
                    fetch(`${TMDB_BASE_URL}/movie/popular?api_key=${TMDB_API_KEY}&page=2`),
                    fetch(`${TMDB_BASE_URL}/movie/popular?api_key=${TMDB_API_KEY}&page=3`)
                ]);
                
                const [data1, data2, data3] = await Promise.all([page1.json(), page2.json(), page3.json()]);
                
                // Store all movies for load more functionality
                allMovies = [...data1.results, ...data2.results, ...data3.results].map(item => ({...item, media_type: 'movie'}));
                
                // Initially show first 24 movies
                moviesLoaded = 24;
                const initialMovies = allMovies.slice(0, moviesLoaded);
                displayResults(initialMovies, moviesDiv);
                
                // Update load more button
                updateLoadMoreButton('movies');
                
            } catch (error) {
                console.error('Error loading popular movies:', error);
                moviesDiv.innerHTML = '<div class="no-results"><h3>⚠️ Error Loading Movies</h3><p>Please try again later.</p></div>';
            }
        }

        async function loadPopularTVShows() {
            const tvDiv = document.getElementById('popularTVShows');
            tvDiv.innerHTML = '<div class="loading"><div class="spinner"></div><p>Loading popular TV shows...</p></div>';
            
            try {
                // Fetch from multiple pages to get more content
                const [page1, page2, page3] = await Promise.all([
                    fetch(`${TMDB_BASE_URL}/tv/popular?api_key=${TMDB_API_KEY}&page=1`),
                    fetch(`${TMDB_BASE_URL}/tv/popular?api_key=${TMDB_API_KEY}&page=2`),
                    fetch(`${TMDB_BASE_URL}/tv/popular?api_key=${TMDB_API_KEY}&page=3`)
                ]);
                
                const [data1, data2, data3] = await Promise.all([page1.json(), page2.json(), page3.json()]);
                
                // Store all TV shows for load more functionality
                allTVShows = [...data1.results, ...data2.results, ...data3.results].map(item => ({...item, media_type: 'tv'}));
                
                // Initially show first 24 TV shows
                tvShowsLoaded = 24;
                const initialTVShows = allTVShows.slice(0, tvShowsLoaded);
                displayResults(initialTVShows, tvDiv);
                
                // Update load more button
                updateLoadMoreButton('tv');
                
            } catch (error) {
                console.error('Error loading popular TV shows:', error);
                tvDiv.innerHTML = '<div class="no-results"><h3>⚠️ Error Loading TV Shows</h3><p>Please try again later.</p></div>';
            }
        }

        function loadMoreMovies() {
            const newMoviesLoaded = Math.min(moviesLoaded + 12, allMovies.length);
            const moviesDiv = document.getElementById('popularMovies');
            
            // Get the new movies to add
            const newMovies = allMovies.slice(moviesLoaded, newMoviesLoaded);
            
            // Append new movies to existing content
            newMovies.forEach(movie => {
                const card = createMediaCard(movie);
                moviesDiv.appendChild(card);
            });
            
            moviesLoaded = newMoviesLoaded;
            updateLoadMoreButton('movies');
            
            // Smooth scroll to the new content
            setTimeout(() => {
                const lastCard = moviesDiv.lastElementChild;
                if (lastCard) {
                    lastCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 100);
        }

        function loadMoreTVShows() {
            const newTVShowsLoaded = Math.min(tvShowsLoaded + 12, allTVShows.length);
            const tvDiv = document.getElementById('popularTVShows');
            
            // Get the new TV shows to add
            const newTVShows = allTVShows.slice(tvShowsLoaded, newTVShowsLoaded);
            
            // Append new TV shows to existing content
            newTVShows.forEach(tvShow => {
                const card = createMediaCard(tvShow);
                tvDiv.appendChild(card);
            });
            
            tvShowsLoaded = newTVShowsLoaded;
            updateLoadMoreButton('tv');
            
            // Smooth scroll to the new content
            setTimeout(() => {
                const lastCard = tvDiv.lastElementChild;
                if (lastCard) {
                    lastCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 100);
        }

        function updateLoadMoreButton(type) {
            if (type === 'movies') {
                const button = document.getElementById('loadMoreMoviesBtn');
                if (moviesLoaded >= allMovies.length) {
                    button.style.display = 'none';
                } else {
                    button.style.display = 'block';
                    button.textContent = `Load More (${allMovies.length - moviesLoaded} remaining)`;
                }
            } else if (type === 'tv') {
                const button = document.getElementById('loadMoreTVBtn');
                if (tvShowsLoaded >= allTVShows.length) {
                    button.style.display = 'none';
                } else {
                    button.style.display = 'block';
                    button.textContent = `Load More (${allTVShows.length - tvShowsLoaded} remaining)`;
                }
            }
        }

        // Browse all content with pagination
        async function showAllMovies() {
            currentBrowseType = 'movie';
            currentPage = 1;
            await loadBrowseContent();
        }

        async function showAllTVShows() {
            currentBrowseType = 'tv';
            currentPage = 1;
            await loadBrowseContent();
        }

        async function loadBrowseContent() {
            document.getElementById('mainContent').style.display = 'none';
            document.getElementById('searchResultsSection').style.display = 'none';
            document.getElementById('browseSection').style.display = 'block';
            
            const browseTitle = document.getElementById('browseTitle');
            browseTitle.textContent = currentBrowseType === 'movie' ? '🍿 All Movies' : '📺 All TV Shows';
            
            const browseResults = document.getElementById('browseResults');
            browseResults.innerHTML = '<div class="loading"><div class="spinner"></div><p>Loading content...</p></div>';
            
            try {
                const response = await fetch(`${TMDB_BASE_URL}/${currentBrowseType}/popular?api_key=${TMDB_API_KEY}&page=${currentPage}`);
                const data = await response.json();
                
                totalPages = Math.min(data.total_pages, 500); // TMDB limits to 500 pages
                const content = data.results.map(item => ({...item, media_type: currentBrowseType}));
                
                displayResults(content, browseResults);
                setupPagination();
                
            } catch (error) {
                console.error('Error loading browse content:', error);
                browseResults.innerHTML = '<div class="no-results"><h3>⚠️ Error Loading Content</h3><p>Please try again later.</p></div>';
            }
        }

        function setupPagination() {
            const pagination = document.getElementById('browsePagination');
            pagination.style.display = 'flex';
            
            let paginationHTML = '';
            
            // Previous button
            paginationHTML += `<button class="page-btn" ${currentPage === 1 ? 'disabled' : ''} onclick="changePage(${currentPage - 1})">← Previous</button>`;
            
            // Page numbers
            const startPage = Math.max(1, currentPage - 2);
            const endPage = Math.min(totalPages, currentPage + 2);
            
            if (startPage > 1) {
                paginationHTML += `<button class="page-btn" onclick="changePage(1)">1</button>`;
                if (startPage > 2) {
                    paginationHTML += `<span class="page-info">...</span>`;
                }
            }
            
            for (let i = startPage; i <= endPage; i++) {
                paginationHTML += `<button class="page-btn ${i === currentPage ? 'active' : ''}" onclick="changePage(${i})">${i}</button>`;
            }
            
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    paginationHTML += `<span class="page-info">...</span>`;
                }
                paginationHTML += `<button class="page-btn" onclick="changePage(${totalPages})">${totalPages}</button>`;
            }
            
            // Next button
            paginationHTML += `<button class="page-btn" ${currentPage === totalPages ? 'disabled' : ''} onclick="changePage(${currentPage + 1})">Next →</button>`;
            
            // Page info
            paginationHTML += `<span class="page-info">Page ${currentPage} of ${totalPages}</span>`;
            
            pagination.innerHTML = paginationHTML;
        }

        async function changePage(page) {
            if (page < 1 || page > totalPages || page === currentPage) return;
            
            currentPage = page;
            await loadBrowseContent();
            
            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // Browse all content with pagination
        async function showAllMovies() {
            currentBrowseType = 'movie';
            currentPage = 1;
            await loadBrowseContent();
        }

        async function showAllTVShows() {
            currentBrowseType = 'tv';
            currentPage = 1;
            await loadBrowseContent();
        }

        async function loadBrowseContent() {
            // For now, just show more popular content
            // This can be enhanced later with pagination
            console.log('Loading browse content for:', currentBrowseType);
            
            try {
                let response;
                if (currentBrowseType === 'movie') {
                    response = await fetch(`${TMDB_BASE_URL}/movie/popular?api_key=${TMDB_API_KEY}&page=1`);
                } else {
                    response = await fetch(`${TMDB_BASE_URL}/tv/popular?api_key=${TMDB_API_KEY}&page=1`);
                }
                
                const data = await response.json();
                const content = data.results.map(item => ({...item, media_type: currentBrowseType}));
                
                // Show in search results area
                const searchResults = document.getElementById('searchResults');
                const mainContent = document.getElementById('mainContent');
                
                mainContent.style.display = 'none';
                searchResults.style.display = 'grid';
                
                displayResults(content, searchResults);
                
            } catch (error) {
                console.error('Error loading browse content:', error);
            }
        }

        function backToHome() {
            document.getElementById('searchResults').style.display = 'none';
            document.getElementById('mainContent').style.display = 'block';
        }

        function clearSearch() {
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.value = '';
            }
            document.getElementById('searchResults').style.display = 'none';
            document.getElementById('mainContent').style.display = 'block';
        }

        // Display results
        function displayResults(results, container) {
            console.log('📋 displayResults called with:', {
                resultsLength: results.length,
                containerElement: !!container,
                containerId: container?.id
            });
            
            if (!container) {
                console.error('❌ Container not found for displaying results');
                return;
            }
            
            if (results.length === 0) {
                console.log('📋 No results to display');
                container.innerHTML = '<div class="no-results"><h3>🔍 No Results Found</h3><p>Try a different search term.</p></div>';
                return;
            }
            
            console.log('📋 Clearing container and creating cards...');
            container.innerHTML = '';
            
            // Remove the test element - no longer needed
            
            results.forEach((item, index) => {
                console.log(`📋 Creating card ${index + 1}/${results.length} for:`, item.title || item.name);
                try {
                    const card = createMediaCard(item);
                    container.appendChild(card);
                    console.log(`✅ Card ${index + 1} added successfully`);
                } catch (error) {
                    console.error(`❌ Error creating card ${index + 1}:`, error);
                }
            });
            
            console.log('✅ displayResults completed - all cards should be visible now');
        }

        // Create media card with bot integration
        function createMediaCard(item) {
            const card = document.createElement('div');
            card.className = 'media-card';
            
            const title = item.title || item.name;
            const year = item.release_date || item.first_air_date;
            const mediaType = item.media_type || currentMediaType;
            const mediaId = mediaType + '-' + item.id;
            
            const userRequest = userRequests.get(mediaId);
            let buttonText = 'Request ' + (mediaType === 'tv' ? 'Episodes' : 'Movie');
            let buttonClass = 'request-btn';
            let buttonDisabled = false;
            let episodeStatusHTML = '';
            
            // For TV shows, show requested episodes but don't disable button
            if (mediaType === 'tv' && userRequest && userRequest.selectedEpisodes) {
                const episodeInfo = formatRequestedEpisodes(userRequest.selectedEpisodes, userRequest.status);
                if (episodeInfo) {
                    episodeStatusHTML = `<div class="episode-status" style="margin-bottom: 10px; padding: 8px; background: rgba(40, 167, 69, 0.1); border-radius: 6px; border: 1px solid rgba(40, 167, 69, 0.3); font-size: 0.8rem; line-height: 1.5;">${episodeInfo}</div>`;
                }
                buttonText = 'Request More Episodes';
            } else if (mediaType === 'movie' && userRequest) {
                buttonDisabled = true;
                switch (userRequest.status) {
                    case 'pending':
                        buttonText = 'Pending ⏳';
                        buttonClass = 'request-btn pending';
                        break;
                    case 'approved':
                        buttonText = 'Approved ✅';
                        buttonClass = 'request-btn approved';
                        break;
                    case 'not_available':
                        buttonText = 'Not Available 🚫';
                        buttonClass = 'request-btn not_available';
                        break;
                    case 'no_storage':
                        buttonText = 'No Storage 💾';
                        buttonClass = 'request-btn no_storage';
                        break;
                    case 'already_exists':
                        buttonText = 'Already Available 📦';
                        buttonClass = 'request-btn already_exists';
                        break;
                    case 'downloading':
                        buttonText = 'Downloading ⬇️';
                        buttonClass = 'request-btn downloading';
                        break;
                    case 'error':
                        buttonText = 'Error ⚠️';
                        buttonClass = 'request-btn error';
                        break;
                }
            }
            
            // Check weekly limit (but not for TV shows that already have requests)
            if (!userRequest && userTier !== 'VIP' && userRequestCount >= weeklyLimit) {
                buttonDisabled = true;
                buttonText = 'Weekly Limit Reached';
            }
            
            // Create safe title for SVG (remove special characters and emojis)
            const safeTitle = title.replace(/[^\x00-\x7F]/g, "").substring(0, 30) || "Media";
            
            let posterPath;
            if (item.poster_path) {
                posterPath = 'https://image.tmdb.org/t/p/w500' + item.poster_path;
            } else {
                // Use a simple fallback instead of SVG to avoid encoding issues
                posterPath = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
                    <svg width="300" height="450" xmlns="http://www.w3.org/2000/svg">
                        <rect width="300" height="450" fill="#1a1a3a"/>
                        <text x="150" y="200" font-family="Arial" font-size="16" fill="white" text-anchor="middle">
                            ${safeTitle}
                        </text>
                        <circle cx="150" cy="300" r="30" fill="#4ecdc4" opacity="0.3"/>
                        <text x="150" y="305" font-family="Arial" font-size="24" fill="#4ecdc4" text-anchor="middle">🎬</text>
                    </svg>
                `);
            }
            
            // Create the card HTML without inline onclick to avoid quote issues
            card.innerHTML = `
                <img src="${posterPath}" alt="${title}" class="media-poster">
                <div class="media-info">
                    <h3 class="media-title">${title}</h3>
                    <div class="media-meta">
                        <span class="media-year">${year ? new Date(year).getFullYear() : 'Unknown'}</span>
                        <span class="media-type-badge">${mediaType === 'tv' ? 'TV' : 'Movie'}</span>
                    </div>
                    <p class="media-overview">${item.overview || 'No description available.'}</p>
                    ${episodeStatusHTML}
                    <button class="${buttonClass}" id="btn-${mediaId}" ${buttonDisabled ? 'disabled' : ''}>
                        ${buttonText}
                    </button>
                </div>
            `;
            
            // Add event listener to the button instead of inline onclick
            const button = card.querySelector(`#btn-${mediaId}`);
            if (button && !buttonDisabled) {
                button.addEventListener('click', function() {
                    requestMedia(item);
                });
            }
            
            return card;
        }

        // Request media - this submits to Firebase for your bot to process
        async function requestMedia(media) {
            if (!currentUser) {
                alert('Please sign in to make requests.');
                return;
            }
            
            if (userTier !== 'VIP' && userRequestCount >= weeklyLimit) {
                alert(`You've reached your weekly limit of ${weeklyLimit} requests. Limit resets on Sunday.`);
                return;
            }
            
            selectedMedia = media;
            const mediaType = media.media_type || currentMediaType;
            
            if (mediaType === 'tv') {
                await showSeasonSelector(media.id);
            } else {
                selectedEpisodes = {};
                await submitRequest();
            }
        }

        // Submit request to Firebase (your bot will pick this up)
        async function submitRequest() {
            console.log('📤 Submitting request to Firebase for bot processing');
            if (!currentUser || !selectedMedia) return;
            
            const mediaType = selectedMedia.media_type || currentMediaType;
            const episodeData = {};
            
            for (const [season, episodes] of Object.entries(selectedEpisodes)) {
                episodeData[`S${String(season).padStart(2, '0')}`] = episodes.sort((a, b) => a - b);
            }
            
            const requestData = {
                tmdbId: selectedMedia.id,
                title: selectedMedia.title || selectedMedia.name,
                mediaType: mediaType === 'tv' ? 'tv' : 'movie',
                poster_path: selectedMedia.poster_path,
                userName: currentUser.name,
                userEmail: currentUser.email,
                userId: currentUser.id,
                selectedEpisodes: episodeData,
                timestamp: new Date(),
                status: 'pending',
                statusText: 'Pending Review'
            };
            
            try {
                const requestsRef = window.collection(window.db, `artifacts/${APP_ID}/public/data/requests`);
                const docRef = await window.addDoc(requestsRef, requestData);
                console.log('✅ Request submitted to Firebase for bot processing, ID:', docRef.id);
                
                // Update user request count if not VIP
                if (userTier !== 'VIP') {
                    userRequestCount++;
                    const userDocRef = window.doc(window.db, `artifacts/${APP_ID}/public/data/users`, currentUser.id);
                    await window.updateDoc(userDocRef, { requestCount: userRequestCount });
                }
                
                let summaryText = '';
                if (mediaType === 'tv' && Object.keys(episodeData).length > 0) {
                    for (const [season, episodes] of Object.entries(episodeData)) {
                        const seasonNum = parseInt(season.replace('S', ''));
                        const seasonDetails = tvShowDetails?.seasons?.find(s => s.season_number === seasonNum);
                        const totalEpisodes = seasonDetails ? seasonDetails.episode_count : episodes.length;
                        
                        if (episodes.length === totalEpisodes) {
                            summaryText += `\n  • ${season}: All episodes`;
                        } else {
                            summaryText += `\n  • ${season}: Episodes ${episodes.join(', ')}`;
                        }
                    }
                }
                
                updateUserInfoDisplay();
                alert(`✅ Request submitted successfully for ${requestData.title}!${summaryText}\n\nYour bot will process this request and update the status automatically.`);
                
                selectedMedia = null;
                selectedEpisodes = {};
                tvShowDetails = null;
                
            } catch (error) {
                console.error('❌ Request submission error:', error);
                alert('Error submitting request: ' + error.message);
                throw error;
            }
        }

        // Load user requests from Firebase
        async function loadUserRequests() {
            if (!window.db || !currentUser) return;
            
            try {
                const requestsRef = window.collection(window.db, `artifacts/${APP_ID}/public/data/requests`);
                const snapshot = await window.getDocs(requestsRef);
                
                const userDocId = currentUser.email.replace(/[.@]/g, '_');
                
                snapshot.forEach((doc) => {
                    const data = doc.data();
                    if (data.userId === currentUser.id || data.userId === userDocId) {
                        const mediaId = data.mediaType + '-' + data.tmdbId;
                        
                        if (data.mediaType === 'tv') {
                            const existingRequest = userRequests.get(mediaId);
                            if (existingRequest && existingRequest.selectedEpisodes) {
                                for (const [season, episodes] of Object.entries(data.selectedEpisodes || {})) {
                                    if (!existingRequest.selectedEpisodes[season]) {
                                        existingRequest.selectedEpisodes[season] = [];
                                    }
                                    existingRequest.selectedEpisodes[season] = [
                                        ...new Set([...existingRequest.selectedEpisodes[season], ...episodes])
                                    ].sort((a, b) => a - b);
                                }
                                if (data.status === 'approved' || existingRequest.status !== 'approved') {
                                    existingRequest.status = data.status;
                                }
                            } else {
                                userRequests.set(mediaId, data);
                            }
                        } else {
                            userRequests.set(mediaId, data);
                        }
                    }
                });
                
                console.log('📋 Loaded user requests:', userRequests.size);
            } catch (error) {
                console.error('Error loading user requests:', error);
            }
        }

        // Listen for real-time request updates from your bot
        async function listenForRequestUpdates() {
            if (!window.db || !currentUser) return;
            
            try {
                const requestsRef = window.collection(window.db, `artifacts/${APP_ID}/public/data/requests`);
                const userDocId = currentUser.email.replace(/[.@]/g, '_');
                
                window.onSnapshot(requestsRef, (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        const data = change.doc.data();
                        if ((data.userId === currentUser.id || data.userId === userDocId)) {
                            const mediaId = data.mediaType + '-' + data.tmdbId;
                            
                            if (change.type === 'modified' || change.type === 'added') {
                                console.log('📱 Request update from bot:', {
                                    mediaId: mediaId,
                                    status: data.status,
                                    changeType: change.type
                                });
                                
                                if (data.mediaType === 'tv') {
                                    const existingRequest = userRequests.get(mediaId);
                                    if (existingRequest && existingRequest.selectedEpisodes) {
                                        for (const [season, episodes] of Object.entries(data.selectedEpisodes || {})) {
                                            if (!existingRequest.selectedEpisodes[season]) {
                                                existingRequest.selectedEpisodes[season] = [];
                                            }
                                            existingRequest.selectedEpisodes[season] = [
                                                ...new Set([...existingRequest.selectedEpisodes[season], ...episodes])
                                            ].sort((a, b) => a - b);
                                        }
                                        existingRequest.status = data.status;
                                    } else {
                                        userRequests.set(mediaId, data);
                                    }
                                } else {
                                    userRequests.set(mediaId, data);
                                }
                                
                                updateMediaCardDisplay(mediaId);
                            }
                        }
                    });
                });
            } catch (error) {
                console.error('Error setting up request listener:', error);
            }
        }

        function updateMediaCardDisplay(mediaId) {
            const button = document.getElementById('btn-' + mediaId);
            if (!button) return;
            
            const mediaCard = button.closest('.media-card');
            if (!mediaCard) return;
            
            const userRequest = userRequests.get(mediaId);
            if (!userRequest) return;
            
            if (userRequest.mediaType === 'tv') {
                let statusDiv = mediaCard.querySelector('.episode-status');
                if (!statusDiv) {
                    statusDiv = document.createElement('div');
                    statusDiv.className = 'episode-status';
                    statusDiv.style.cssText = 'margin-bottom: 10px; padding: 8px; background: rgba(40, 167, 69, 0.1); border-radius: 6px; border: 1px solid rgba(40, 167, 69, 0.3); font-size: 0.8rem; line-height: 1.5;';
                    button.parentNode.insertBefore(statusDiv, button);
                }
                
                const episodeInfo = formatRequestedEpisodes(userRequest.selectedEpisodes, userRequest.status);
                if (episodeInfo) {
                    statusDiv.innerHTML = episodeInfo;
                    statusDiv.style.display = 'block';
                }
                
                button.textContent = 'Request More Episodes';
                button.disabled = false;
            } else {
                updateButtonStatus(mediaId, userRequest.status);
            }
        }

        function updateButtonStatus(mediaId, status) {
            const button = document.getElementById('btn-' + mediaId);
            if (!button) return;
            
            button.disabled = true;
            button.className = 'request-btn ' + status;
            
            switch (status) {
                case 'pending':
                    button.textContent = 'Pending ⏳';
                    break;
                case 'approved':
                    button.textContent = 'Approved ✅';
                    break;
                case 'not_available':
                    button.textContent = 'Not Available 🚫';
                    break;
                case 'no_storage':
                    button.textContent = 'No Storage 💾';
                    break;
                case 'already_exists':
                    button.textContent = 'Already Available 📦';
                    break;
                case 'downloading':
                    button.textContent = 'Downloading ⬇️';
                    break;
                case 'error':
                    button.textContent = 'Error ⚠️';
                    break;
            }
        }

        function formatRequestedEpisodes(episodeData, status) {
            if (!episodeData || Object.keys(episodeData).length === 0) {
                return null;
            }
            
            const baseStyle = 'display: inline-block; margin: 2px 4px; padding: 2px 6px; color: white; border-radius: 4px; font-size: 0.75rem; font-weight: 500;';
            
            let bgColor = 'background: linear-gradient(45deg, #28a745, #218838);'; // approved
            if (status === 'pending') {
                bgColor = 'background: linear-gradient(45deg, #6c757d, #5a6268);';
            } else if (status === 'downloading') {
                bgColor = 'background: linear-gradient(45deg, #0099ff, #007acc);';
            } else if (status === 'error' || status === 'not_available') {
                bgColor = 'background: linear-gradient(45deg, #dc3545, #c82333);';
            }
            
            const formattedItems = [];
            
            for (const [season, episodes] of Object.entries(episodeData)) {
                if (!episodes || episodes.length === 0) continue;
                
                const seasonNum = season.replace('S', '');
                const sortedEpisodes = episodes.sort((a, b) => a - b);
                
                const ranges = [];
                let start = sortedEpisodes[0];
                let end = sortedEpisodes[0];
                
                for (let i = 1; i < sortedEpisodes.length; i++) {
                    if (sortedEpisodes[i] === end + 1) {
                        end = sortedEpisodes[i];
                    } else {
                        if (start === end) {
                            ranges.push(`E${String(start).padStart(2, '0')}`);
                        } else {
                            ranges.push(`E${String(start).padStart(2, '0')}-E${String(end).padStart(2, '0')}`);
                        }
                        start = sortedEpisodes[i];
                        end = sortedEpisodes[i];
                    }
                }
                
                if (start === end) {
                    ranges.push(`E${String(start).padStart(2, '0')}`);
                } else {
                    ranges.push(`E${String(start).padStart(2, '0')}-E${String(end).padStart(2, '0')}`);
                }
                
                const seasonText = `${season}: ${ranges.join(', ')}`;
                formattedItems.push(`<span style="${baseStyle} ${bgColor}">${seasonText}</span>`);
            }
            
            const statusIcon = status === 'approved' ? '✅' : 
                             status === 'pending' ? '⏳' : 
                             status === 'downloading' ? '⬇️' : 
                             status === 'error' ? '⚠️' : '';
            
            return `<strong>Requested Episodes ${statusIcon}:</strong> ${formattedItems.join(' ')}`;
        }

        // TV Show Episode Selection Functions
        async function showSeasonSelector(tvId) {
            try {
                document.getElementById('seasonContent').innerHTML = 
                    '<div style="text-align: center; padding: 20px; color: #a0a0a0;"><div class="spinner"></div><p>Loading episode information...</p></div>';
                
                document.getElementById('seasonModal').style.display = 'block';
                document.getElementById('selectionSummary').style.display = 'none';
                
                selectedEpisodes = {};
                
                const response = await fetch(TMDB_BASE_URL + '/tv/' + tvId + '?api_key=' + TMDB_API_KEY);
                tvShowDetails = await response.json();
                
                let contentHTML = '';
                const regularSeasons = tvShowDetails.seasons.filter(season => season.season_number > 0);
                
                for (const season of regularSeasons) {
                    const seasonResponse = await fetch(
                        TMDB_BASE_URL + '/tv/' + tvId + '/season/' + season.season_number + '?api_key=' + TMDB_API_KEY
                    );
                    const seasonDetails = await seasonResponse.json();
                    
                    contentHTML += `
                        <div style="margin-bottom: 20px; padding: 15px; background: rgba(255, 255, 255, 0.05); border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.1);" data-season="${season.season_number}">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid rgba(255, 255, 255, 0.2); flex-wrap: wrap; gap: 10px;">
                                <div style="font-size: 1.1rem; font-weight: 600; color: #4ecdc4;">
                                    Season ${season.season_number}
                                    <span style="display: inline-block; padding: 2px 6px; background: rgba(255, 255, 255, 0.2); border-radius: 4px; font-size: 0.7rem; margin-left: 8px;">${seasonDetails.episodes.length} episodes</span>
                                </div>
                                <button onclick="toggleAllEpisodes(${season.season_number})" style="padding: 6px 12px; background: linear-gradient(45deg, #ff6b6b, #ff8e53); border: none; border-radius: 6px; color: #ffffff; font-size: 0.8rem; font-weight: 600; cursor: pointer; -webkit-tap-highlight-color: transparent; touch-action: manipulation;">
                                    Select All
                                </button>
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); gap: 8px;" id="episodes-${season.season_number}">
                    `;
                    
                    for (const episode of seasonDetails.episodes) {
                        const episodeTitle = episode.name || `Episode ${episode.episode_number}`;
                        contentHTML += `
                            <div onclick="toggleEpisode(${season.season_number}, ${episode.episode_number})" data-season="${season.season_number}" data-episode="${episode.episode_number}" style="padding: 8px 6px; background: rgba(255, 255, 255, 0.08); border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 6px; color: #ffffff; font-size: 0.8rem; cursor: pointer; transition: all 0.2s ease; text-align: center; position: relative; -webkit-tap-highlight-color: transparent; touch-action: manipulation;">
                                <div>E${String(episode.episode_number).padStart(2, '0')}</div>
                                <div style="font-size: 0.7rem; color: #a0a0a0; margin-top: 4px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${episodeTitle}">${episodeTitle}</div>
                            </div>
                        `;
                    }
                    
                    contentHTML += `</div></div>`;
                }
                
                document.getElementById('seasonContent').innerHTML = contentHTML;
                
            } catch (error) {
                console.error('Error loading season information:', error);
                document.getElementById('seasonContent').innerHTML = 
                    '<div style="text-align: center; padding: 40px; color: #a0a0a0;"><h3>⚠️ Error Loading Episodes</h3><p>Unable to load episode information. Please try again.</p></div>';
            }
        }

        function toggleEpisode(seasonNumber, episodeNumber) {
            if (!selectedEpisodes[seasonNumber]) {
                selectedEpisodes[seasonNumber] = [];
            }
            
            const index = selectedEpisodes[seasonNumber].indexOf(episodeNumber);
            const episodeBtn = document.querySelector(
                `[data-season="${seasonNumber}"][data-episode="${episodeNumber}"]`
            );
            
            if (index > -1) {
                selectedEpisodes[seasonNumber].splice(index, 1);
                episodeBtn.style.background = 'rgba(255, 255, 255, 0.08)';
                episodeBtn.style.borderColor = 'rgba(255, 255, 255, 0.15)';
                episodeBtn.style.fontWeight = 'normal';
                
                if (selectedEpisodes[seasonNumber].length === 0) {
                    delete selectedEpisodes[seasonNumber];
                }
            } else {
                selectedEpisodes[seasonNumber].push(episodeNumber);
                episodeBtn.style.background = 'linear-gradient(45deg, #4ecdc4, #45b7d1)';
                episodeBtn.style.borderColor = '#4ecdc4';
                episodeBtn.style.fontWeight = '600';
            }
            
            updateSelectAllButton(seasonNumber);
            updateSelectionSummary();
        }

        function toggleAllEpisodes(seasonNumber) {
            const episodeBtns = document.querySelectorAll(`[data-season="${seasonNumber}"][data-episode]`);
            const selectAllBtn = document.querySelector(`[data-season="${seasonNumber}"] button`);
            
            const allSelected = selectedEpisodes[seasonNumber] && 
                               selectedEpisodes[seasonNumber].length === episodeBtns.length;
            
            if (allSelected) {
                delete selectedEpisodes[seasonNumber];
                episodeBtns.forEach(btn => {
                    btn.style.background = 'rgba(255, 255, 255, 0.08)';
                    btn.style.borderColor = 'rgba(255, 255, 255, 0.15)';
                    btn.style.fontWeight = 'normal';
                });
                selectAllBtn.textContent = 'Select All';
                selectAllBtn.style.background = 'linear-gradient(45deg, #ff6b6b, #ff8e53)';
            } else {
                selectedEpisodes[seasonNumber] = [];
                episodeBtns.forEach(btn => {
                    const episodeNum = parseInt(btn.dataset.episode);
                    selectedEpisodes[seasonNumber].push(episodeNum);
                    btn.style.background = 'linear-gradient(45deg, #4ecdc4, #45b7d1)';
                    btn.style.borderColor = '#4ecdc4';
                    btn.style.fontWeight = '600';
                });
                selectAllBtn.textContent = 'Deselect All';
                selectAllBtn.style.background = 'linear-gradient(45deg, #4ecdc4, #45b7d1)';
            }
            
            updateSelectionSummary();
        }

        function updateSelectAllButton(seasonNumber) {
            const episodeBtns = document.querySelectorAll(`[data-season="${seasonNumber}"][data-episode]`);
            const selectAllBtn = document.querySelector(`[data-season="${seasonNumber}"] button`);
            
            if (!selectAllBtn) return;
            
            const allSelected = selectedEpisodes[seasonNumber] && 
                               selectedEpisodes[seasonNumber].length === episodeBtns.length;
            
            if (allSelected) {
                selectAllBtn.textContent = 'Deselect All';
                selectAllBtn.style.background = 'linear-gradient(45deg, #4ecdc4, #45b7d1)';
            } else {
                selectAllBtn.textContent = 'Select All';
                selectAllBtn.style.background = 'linear-gradient(45deg, #ff6b6b, #ff8e53)';
            }
        }

        function updateSelectionSummary() {
            const summarySection = document.getElementById('selectionSummary');
            const summaryText = document.getElementById('summaryText');
            
            if (Object.keys(selectedEpisodes).length === 0) {
                summarySection.style.display = 'none';
                return;
            }
            
            let summary = '';
            const seasons = Object.keys(selectedEpisodes).sort((a, b) => parseInt(a) - parseInt(b));
            
            for (const season of seasons) {
                const episodes = selectedEpisodes[season].sort((a, b) => a - b);
                const seasonDetails = tvShowDetails.seasons.find(s => s.season_number === parseInt(season));
                const totalEpisodes = seasonDetails ? seasonDetails.episode_count : episodes.length;
                
                if (episodes.length === totalEpisodes) {
                    summary += `<div>• <strong>Season ${season}</strong>: All episodes (${episodes.length})</div>`;
                } else {
                    const ranges = [];
                    let start = episodes[0];
                    let end = episodes[0];
                    
                    for (let i = 1; i < episodes.length; i++) {
                        if (episodes[i] === end + 1) {
                            end = episodes[i];
                        } else {
                            ranges.push(start === end ? `E${start}` : `E${start}-E${end}`);
                            start = episodes[i];
                            end = episodes[i];
                        }
                    }
                    ranges.push(start === end ? `E${start}` : `E${start}-E${end}`);
                    
                    summary += `<div>• <strong>Season ${season}</strong>: ${ranges.join(', ')} (${episodes.length} episodes)</div>`;
                }
            }
            
            summaryText.innerHTML = summary;
            summarySection.style.display = 'block';
        }

        function closeSeasonModal() {
            document.getElementById('seasonModal').style.display = 'none';
            selectedEpisodes = {};
            selectedMedia = null;
            tvShowDetails = null;
        }

        async function confirmRequest() {
            if (Object.keys(selectedEpisodes).length === 0) {
                alert('Please select at least one episode.');
                return;
            }
            
            console.log('✅ Confirming TV show request with episodes:', selectedEpisodes);
            document.getElementById('seasonModal').style.display = 'none';
            
            try {
                await submitRequest();
            } catch (error) {
                console.error('⚠️ Error in confirmRequest:', error);
                alert('Error submitting request: ' + error.message);
            }
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            console.log('📋 DOM loaded, initializing...');
            addTouchSupport();
            
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'light') {
                document.body.classList.add('light-mode');
                document.getElementById('themeIcon').textContent = '☀️';
                document.getElementById('themeText').textContent = 'Dark';
            }
            
            if (!checkSavedSession()) {
                // Load popular content even when not signed in (for preview)
                loadPopularContent();
            }
            
            // Add search input event listener for Enter key
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        console.log('🔍 Search triggered by Enter key');
                        searchMedia();
                    }
                });
                console.log('✅ Search input Enter listener added');
            } else {
                console.error('❌ Search input element not found');
            }
            
            // Add search button click event listener
            const searchBtn = document.getElementById('searchBtn');
            if (searchBtn) {
                searchBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log('🔍 Search button clicked via event listener');
                    searchMedia();
                });
                console.log('✅ Search button click listener added');
            } else {
                console.error('❌ Search button element not found');
            }
            
            // Add season modal event listener
            const seasonModal = document.getElementById('seasonModal');
            if (seasonModal) {
                seasonModal.addEventListener('click', function(e) {
                    if (e.target === this) {
                        closeSeasonModal();
                    }
                });
                console.log('✅ Season modal click listener added');
            } else {
                console.error('❌ Season modal element not found');
            }

            // Add email input event listener
            const emailInput = document.getElementById('emailInput');
            if (emailInput) {
                emailInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        handleEmailSignIn();
                    }
                });
                console.log('✅ Email input Enter listener added');
            }
            
            console.log('✅ All event listeners added successfully');
        });

        console.log('🎬 Fixed Plex Portal loaded successfully!');
        
        // Debug functions - you can call these in the browser console
        window.testSearch = function() {
            console.log('🧪 Testing search function');
            document.getElementById('searchInput').value = 'batman';
            searchMedia();
        };
        
        window.testMediaType = function(type) {
            console.log('🧪 Testing media type change to:', type);
            changeMediaType(type);
        };
        
        window.debugState = function() {
            console.log('🐛 Current state:', {
                currentMediaType: currentMediaType,
                currentUser: currentUser,
                searchInput: document.getElementById('searchInput')?.value,
                mainContentVisible: document.getElementById('mainContent')?.style.display !== 'none',
                searchResultsVisible: document.getElementById('searchResults')?.style.display !== 'none'
            });
        };
        
        window.debugSearchResults = function() {
            const searchResults = document.getElementById('searchResults');
            const mainContent = document.getElementById('mainContent');
            const body = document.body;
            
            console.log('🔍 SEARCH RESULTS DEBUG:', {
                element: searchResults,
                exists: !!searchResults,
                display: searchResults?.style.display,
                computedDisplay: searchResults ? window.getComputedStyle(searchResults).display : 'none',
                visibility: searchResults ? window.getComputedStyle(searchResults).visibility : 'none',
                position: searchResults ? window.getComputedStyle(searchResults).position : 'none',
                bounds: searchResults ? searchResults.getBoundingClientRect() : null,
                childCount: searchResults ? searchResults.children.length : 0,
                innerHTML: searchResults ? searchResults.innerHTML.substring(0, 200) + '...' : 'none'
            });
            
            console.log('🔍 MAIN CONTENT DEBUG:', {
                element: mainContent,
                exists: !!mainContent,
                display: mainContent?.style.display,
                computedDisplay: mainContent ? window.getComputedStyle(mainContent).display : 'none'
            });
            
            // Create a completely new test element that bypasses all existing CSS
            const testElement = document.createElement('div');
            testElement.id = 'emergency-test';
            testElement.innerHTML = `
                <h1>EMERGENCY TEST - CAN YOU SEE THIS?</h1>
                <p>If you can see this, the JavaScript is working!</p>
                <p>Search results children: ${searchResults ? searchResults.children.length : 'none'}</p>
            `;
            testElement.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                background: yellow !important;
                color: black !important;
                z-index: 999999 !important;
                padding: 50px !important;
                font-size: 24px !important;
                border: 10px solid red !important;
                box-sizing: border-box !important;
            `;
            
            // Remove any existing test
            const existing = document.getElementById('emergency-test');
            if (existing) existing.remove();
            
            // Add to body
            body.appendChild(testElement);
            console.log('🔍 Added emergency test element to body');
            
            // Also try to make search results super visible
            if (searchResults) {
                searchResults.style.cssText = `
                    display: block !important;
                    position: fixed !important;
                    top: 50px !important;
                    left: 50px !important;
                    width: 90% !important;
                    height: 400px !important;
                    background: red !important;
                    border: 5px solid yellow !important;
                    z-index: 9999 !important;
                    overflow: auto !important;
                `;
                console.log('🔍 Applied emergency styles to search results');
            }
        };
        
        window.removeEmergencyTest = function() {
            const existing = document.getElementById('emergency-test');
            if (existing) {
                existing.remove();
                console.log('🔍 Removed emergency test element');
            }
        };
        
        console.log('🧪 Debug functions available: testSearch(), testMediaType(type), debugState(), debugSearchResults()');
    </script>
</body>
</html>
